{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { wrap } from 'optimism';\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { isField, resultKeyNameFromField, isReference, makeReference, createFragmentMap, shouldInclude, addTypenameToDocument, getDefaultValues, getFragmentDefinitions, getMainDefinition, getQueryDefinition, maybeDeepFreeze, mergeDeepArray, getFragmentFromSelection } from \"../../utilities/index.js\";\nimport { supportsResultCaching } from \"./entityStore.js\";\nimport { getTypenameFromStoreObject } from \"./helpers.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\n;\nfunction missingFromInvariant(err, context) {\n  return new MissingFieldError(err.message, context.path.slice(), context.query, context.clientOnly, context.variables);\n}\nvar StoreReader = function () {\n  function StoreReader(config) {\n    var _this = this;\n    this.config = config;\n    this.executeSelectionSet = wrap(function (options) {\n      return _this.execSelectionSetImpl(options);\n    }, {\n      keyArgs: function keyArgs(options) {\n        return [options.selectionSet, options.objectOrReference, options.context];\n      },\n      makeCacheKey: function makeCacheKey(selectionSet, parent, context) {\n        if (supportsResultCaching(context.store)) {\n          return context.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context.varString);\n        }\n      }\n    });\n    this.knownResults = new WeakMap();\n    this.executeSubSelectedArray = wrap(function (options) {\n      return _this.execSubSelectedArrayImpl(options);\n    }, {\n      makeCacheKey: function makeCacheKey(_a) {\n        var field = _a.field,\n          array = _a.array,\n          context = _a.context;\n        if (supportsResultCaching(context.store)) {\n          return context.store.makeCacheKey(field, array, context.varString);\n        }\n      }\n    });\n    this.config = __assign({\n      addTypename: true\n    }, config);\n  }\n  StoreReader.prototype.diffQueryAgainstStore = function (_a) {\n    var store = _a.store,\n      query = _a.query,\n      _b = _a.rootId,\n      rootId = _b === void 0 ? 'ROOT_QUERY' : _b,\n      variables = _a.variables,\n      _c = _a.returnPartialData,\n      returnPartialData = _c === void 0 ? true : _c;\n    var policies = this.config.cache.policies;\n    variables = __assign(__assign({}, getDefaultValues(getQueryDefinition(query))), variables);\n    var execResult = this.executeSelectionSet({\n      selectionSet: getMainDefinition(query).selectionSet,\n      objectOrReference: makeReference(rootId),\n      context: {\n        store: store,\n        query: query,\n        policies: policies,\n        variables: variables,\n        varString: JSON.stringify(variables),\n        fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n        path: [],\n        clientOnly: false\n      }\n    });\n    var hasMissingFields = execResult.missing && execResult.missing.length > 0;\n    if (hasMissingFields && !returnPartialData) {\n      throw execResult.missing[0];\n    }\n    return {\n      result: execResult.result,\n      missing: execResult.missing,\n      complete: !hasMissingFields\n    };\n  };\n  StoreReader.prototype.isFresh = function (result, parent, selectionSet, context) {\n    if (supportsResultCaching(context.store) && this.knownResults.get(result) === selectionSet) {\n      var latest = this.executeSelectionSet.peek(selectionSet, parent, context);\n      if (latest && result === latest.result) {\n        return true;\n      }\n    }\n    return false;\n  };\n  StoreReader.prototype.execSelectionSetImpl = function (_a) {\n    var _this = this;\n    var selectionSet = _a.selectionSet,\n      objectOrReference = _a.objectOrReference,\n      context = _a.context;\n    if (isReference(objectOrReference) && !context.policies.rootTypenamesById[objectOrReference.__ref] && !context.store.has(objectOrReference.__ref)) {\n      return {\n        result: {},\n        missing: [missingFromInvariant(process.env.NODE_ENV === \"production\" ? new InvariantError(4) : new InvariantError(\"Dangling reference to missing \" + objectOrReference.__ref + \" object\"), context)]\n      };\n    }\n    var variables = context.variables,\n      policies = context.policies,\n      store = context.store;\n    var objectsToMerge = [];\n    var finalResult = {\n      result: null\n    };\n    var typename = store.getFieldValue(objectOrReference, \"__typename\");\n    if (this.config.addTypename && typeof typename === \"string\" && !policies.rootIdsByTypename[typename]) {\n      objectsToMerge.push({\n        __typename: typename\n      });\n    }\n    function getMissing() {\n      return finalResult.missing || (finalResult.missing = []);\n    }\n    function handleMissing(result) {\n      var _a;\n      if (result.missing) (_a = getMissing()).push.apply(_a, result.missing);\n      return result.result;\n    }\n    var workSet = new Set(selectionSet.selections);\n    workSet.forEach(function (selection) {\n      var _a;\n      if (!shouldInclude(selection, variables)) return;\n      if (isField(selection)) {\n        var fieldValue = policies.readField({\n          fieldName: selection.name.value,\n          field: selection,\n          variables: context.variables,\n          from: objectOrReference\n        }, context);\n        var resultName = resultKeyNameFromField(selection);\n        context.path.push(resultName);\n        var wasClientOnly = context.clientOnly;\n        context.clientOnly = wasClientOnly || !!(selection.directives && selection.directives.some(function (d) {\n          return d.name.value === \"client\";\n        }));\n        if (fieldValue === void 0) {\n          if (!addTypenameToDocument.added(selection)) {\n            getMissing().push(missingFromInvariant(process.env.NODE_ENV === \"production\" ? new InvariantError(5) : new InvariantError(\"Can't find field '\" + selection.name.value + \"' on \" + (isReference(objectOrReference) ? objectOrReference.__ref + \" object\" : \"object \" + JSON.stringify(objectOrReference, null, 2))), context));\n          }\n        } else if (Array.isArray(fieldValue)) {\n          fieldValue = handleMissing(_this.executeSubSelectedArray({\n            field: selection,\n            array: fieldValue,\n            context: context\n          }));\n        } else if (!selection.selectionSet) {\n          if (process.env.NODE_ENV !== 'production') {\n            assertSelectionSetForIdValue(context.store, selection, fieldValue);\n            maybeDeepFreeze(fieldValue);\n          }\n        } else if (fieldValue != null) {\n          fieldValue = handleMissing(_this.executeSelectionSet({\n            selectionSet: selection.selectionSet,\n            objectOrReference: fieldValue,\n            context: context\n          }));\n        }\n        if (fieldValue !== void 0) {\n          objectsToMerge.push((_a = {}, _a[resultName] = fieldValue, _a));\n        }\n        context.clientOnly = wasClientOnly;\n        invariant(context.path.pop() === resultName);\n      } else {\n        var fragment = getFragmentFromSelection(selection, context.fragmentMap);\n        if (fragment && policies.fragmentMatches(fragment, typename)) {\n          fragment.selectionSet.selections.forEach(workSet.add, workSet);\n        }\n      }\n    });\n    finalResult.result = mergeDeepArray(objectsToMerge);\n    if (process.env.NODE_ENV !== 'production') {\n      Object.freeze(finalResult.result);\n    }\n    this.knownResults.set(finalResult.result, selectionSet);\n    return finalResult;\n  };\n  StoreReader.prototype.execSubSelectedArrayImpl = function (_a) {\n    var _this = this;\n    var field = _a.field,\n      array = _a.array,\n      context = _a.context;\n    var missing;\n    function handleMissing(childResult, i) {\n      if (childResult.missing) {\n        missing = missing || [];\n        missing.push.apply(missing, childResult.missing);\n      }\n      invariant(context.path.pop() === i);\n      return childResult.result;\n    }\n    if (field.selectionSet) {\n      array = array.filter(context.store.canRead);\n    }\n    array = array.map(function (item, i) {\n      if (item === null) {\n        return null;\n      }\n      context.path.push(i);\n      if (Array.isArray(item)) {\n        return handleMissing(_this.executeSubSelectedArray({\n          field: field,\n          array: item,\n          context: context\n        }), i);\n      }\n      if (field.selectionSet) {\n        return handleMissing(_this.executeSelectionSet({\n          selectionSet: field.selectionSet,\n          objectOrReference: item,\n          context: context\n        }), i);\n      }\n      if (process.env.NODE_ENV !== 'production') {\n        assertSelectionSetForIdValue(context.store, field, item);\n      }\n      invariant(context.path.pop() === i);\n      return item;\n    });\n    if (process.env.NODE_ENV !== 'production') {\n      Object.freeze(array);\n    }\n    return {\n      result: array,\n      missing: missing\n    };\n  };\n  return StoreReader;\n}();\nexport { StoreReader };\nfunction assertSelectionSetForIdValue(store, field, fieldValue) {\n  if (!field.selectionSet) {\n    var workSet_1 = new Set([fieldValue]);\n    workSet_1.forEach(function (value) {\n      if (value && typeof value === \"object\") {\n        process.env.NODE_ENV === \"production\" ? invariant(!isReference(value), 6) : invariant(!isReference(value), \"Missing selection set for object of type \" + getTypenameFromStoreObject(store, value) + \" returned for query field \" + field.name.value);\n        Object.values(value).forEach(workSet_1.add, workSet_1);\n      }\n    });\n  }\n}","map":{"version":3,"sources":["../../../src/cache/inmemory/readFromStore.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  DocumentNode,\n  FieldNode,\n  SelectionSetNode,\n} from 'graphql';\nimport { wrap, OptimisticWrapperFunction } from 'optimism';\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport {\n  isField,\n  resultKeyNameFromField,\n  Reference,\n  isReference,\n  makeReference,\n  StoreObject,\n  createFragmentMap,\n  FragmentMap,\n  shouldInclude,\n  addTypenameToDocument,\n  getDefaultValues,\n  getFragmentDefinitions,\n  getMainDefinition,\n  getQueryDefinition,\n  maybeDeepFreeze,\n  mergeDeepArray,\n  getFragmentFromSelection,\n} from '../../utilities';\nimport { Cache } from '../core/types/Cache';\nimport {\n  DiffQueryAgainstStoreOptions,\n  NormalizedCache,\n  ReadMergeModifyContext,\n} from './types';\nimport { supportsResultCaching } from './entityStore';\nimport { getTypenameFromStoreObject } from './helpers';\nimport { Policies } from './policies';\nimport { InMemoryCache } from './inMemoryCache';\nimport { MissingFieldError } from '../core/types/common';\n\nexport type VariableMap = { [name: string]: any };\n\ninterface ReadContext extends ReadMergeModifyContext {\n  query: DocumentNode;\n  policies: Policies;\n  fragmentMap: FragmentMap;\n  path: (string | number)[];\n  clientOnly: boolean;\n};\n\nexport type ExecResult<R = any> = {\n  result: R;\n  missing?: MissingFieldError[];\n};\n\nfunction missingFromInvariant(\n  err: InvariantError,\n  context: ReadContext,\n) {\n  return new MissingFieldError(\n    err.message,\n    context.path.slice(),\n    context.query,\n    context.clientOnly,\n    context.variables,\n  );\n}\n\ntype ExecSelectionSetOptions = {\n  selectionSet: SelectionSetNode;\n  objectOrReference: StoreObject | Reference;\n  context: ReadContext;\n};\n\ntype ExecSubSelectedArrayOptions = {\n  field: FieldNode;\n  array: any[];\n  context: ReadContext;\n};\n\nexport interface StoreReaderConfig {\n  cache: InMemoryCache,\n  addTypename?: boolean;\n}\n\nexport class StoreReader {\n  constructor(private config: StoreReaderConfig) {\n    this.config = { addTypename: true, ...config };\n  }\n\n  /**\n   * Given a store and a query, return as much of the result as possible and\n   * identify if any data was missing from the store.\n   * @param  {DocumentNode} query A parsed GraphQL query document\n   * @param  {Store} store The Apollo Client store object\n   * @return {result: Object, complete: [boolean]}\n   */\n  public diffQueryAgainstStore<T>({\n    store,\n    query,\n    rootId = 'ROOT_QUERY',\n    variables,\n    returnPartialData = true,\n  }: DiffQueryAgainstStoreOptions): Cache.DiffResult<T> {\n    const policies = this.config.cache.policies;\n\n    variables = {\n      ...getDefaultValues(getQueryDefinition(query)),\n      ...variables,\n    };\n\n    const execResult = this.executeSelectionSet({\n      selectionSet: getMainDefinition(query).selectionSet,\n      objectOrReference: makeReference(rootId),\n      context: {\n        store,\n        query,\n        policies,\n        variables,\n        varString: JSON.stringify(variables),\n        fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n        path: [],\n        clientOnly: false,\n      },\n    });\n\n    const hasMissingFields =\n      execResult.missing && execResult.missing.length > 0;\n    if (hasMissingFields && !returnPartialData) {\n      throw execResult.missing![0];\n    }\n\n    return {\n      result: execResult.result,\n      missing: execResult.missing,\n      complete: !hasMissingFields,\n    };\n  }\n\n  public isFresh(\n    result: Record<string, any>,\n    parent: StoreObject | Reference,\n    selectionSet: SelectionSetNode,\n    context: ReadMergeModifyContext,\n  ): boolean {\n    if (supportsResultCaching(context.store) &&\n        this.knownResults.get(result) === selectionSet) {\n      const latest = this.executeSelectionSet.peek(selectionSet, parent, context);\n      if (latest && result === latest.result) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Cached version of execSelectionSetImpl.\n  private executeSelectionSet: OptimisticWrapperFunction<\n    [ExecSelectionSetOptions], // Actual arguments tuple type.\n    ExecResult, // Actual return type.\n    // Arguments type after keyArgs translation.\n    [SelectionSetNode, StoreObject | Reference, ReadMergeModifyContext]\n  > = wrap(options => this.execSelectionSetImpl(options), {\n    keyArgs(options) {\n      return [\n        options.selectionSet,\n        options.objectOrReference,\n        options.context,\n      ];\n    },\n    // Note that the parameters of makeCacheKey are determined by the\n    // array returned by keyArgs.\n    makeCacheKey(selectionSet, parent, context) {\n      if (supportsResultCaching(context.store)) {\n        return context.store.makeCacheKey(\n          selectionSet,\n          isReference(parent) ? parent.__ref : parent,\n          context.varString,\n        );\n      }\n    }\n  });\n\n  // Uncached version of executeSelectionSet.\n  private execSelectionSetImpl({\n    selectionSet,\n    objectOrReference,\n    context,\n  }: ExecSelectionSetOptions): ExecResult {\n    if (isReference(objectOrReference) &&\n        !context.policies.rootTypenamesById[objectOrReference.__ref] &&\n        !context.store.has(objectOrReference.__ref)) {\n      return {\n        result: {},\n        missing: [missingFromInvariant(\n          new InvariantError(\n            `Dangling reference to missing ${objectOrReference.__ref} object`\n          ),\n          context,\n        )],\n      };\n    }\n\n    const { variables, policies, store } = context;\n    const objectsToMerge: { [key: string]: any }[] = [];\n    const finalResult: ExecResult = { result: null };\n    const typename = store.getFieldValue<string>(objectOrReference, \"__typename\");\n\n    if (this.config.addTypename &&\n        typeof typename === \"string\" &&\n        !policies.rootIdsByTypename[typename]) {\n      // Ensure we always include a default value for the __typename\n      // field, if we have one, and this.config.addTypename is true. Note\n      // that this field can be overridden by other merged objects.\n      objectsToMerge.push({ __typename: typename });\n    }\n\n    function getMissing() {\n      return finalResult.missing || (finalResult.missing = []);\n    }\n\n    function handleMissing<T>(result: ExecResult<T>): T {\n      if (result.missing) getMissing().push(...result.missing);\n      return result.result;\n    }\n\n    const workSet = new Set(selectionSet.selections);\n\n    workSet.forEach(selection => {\n      // Omit fields with directives @skip(if: <truthy value>) or\n      // @include(if: <falsy value>).\n      if (!shouldInclude(selection, variables)) return;\n\n      if (isField(selection)) {\n        let fieldValue = policies.readField({\n          fieldName: selection.name.value,\n          field: selection,\n          variables: context.variables,\n          from: objectOrReference,\n        }, context);\n\n        const resultName = resultKeyNameFromField(selection);\n        context.path.push(resultName);\n\n        // If this field has an @client directive, then the field and\n        // everything beneath it is client-only, meaning it will never be\n        // sent to the server.\n        const wasClientOnly = context.clientOnly;\n        // Once we enter a client-only subtree of the query, we can avoid\n        // repeatedly checking selection.directives.\n        context.clientOnly = wasClientOnly || !!(\n          // We don't use the hasDirectives helper here, because it looks\n          // for directives anywhere inside the AST node, whereas we only\n          // care about directives directly attached to this field.\n          selection.directives &&\n          selection.directives.some(d => d.name.value === \"client\")\n        );\n\n        if (fieldValue === void 0) {\n          if (!addTypenameToDocument.added(selection)) {\n            getMissing().push(\n              missingFromInvariant(\n                new InvariantError(`Can't find field '${\n                  selection.name.value\n                }' on ${\n                  isReference(objectOrReference)\n                    ? objectOrReference.__ref + \" object\"\n                    : \"object \" + JSON.stringify(objectOrReference, null, 2)\n                }`),\n                context,\n              ),\n            );\n          }\n\n        } else if (Array.isArray(fieldValue)) {\n          fieldValue = handleMissing(this.executeSubSelectedArray({\n            field: selection,\n            array: fieldValue,\n            context,\n          }));\n\n        } else if (!selection.selectionSet) {\n          // If the field does not have a selection set, then we handle it\n          // as a scalar value. However, that value should not contain any\n          // Reference objects, and should be frozen in development, if it\n          // happens to be an object that is mutable.\n          if (process.env.NODE_ENV !== 'production') {\n            assertSelectionSetForIdValue(\n              context.store,\n              selection,\n              fieldValue,\n            );\n            maybeDeepFreeze(fieldValue);\n          }\n\n        } else if (fieldValue != null) {\n          // In this case, because we know the field has a selection set,\n          // it must be trying to query a GraphQLObjectType, which is why\n          // fieldValue must be != null.\n          fieldValue = handleMissing(this.executeSelectionSet({\n            selectionSet: selection.selectionSet,\n            objectOrReference: fieldValue as StoreObject | Reference,\n            context,\n          }));\n        }\n\n        if (fieldValue !== void 0) {\n          objectsToMerge.push({ [resultName]: fieldValue });\n        }\n\n        context.clientOnly = wasClientOnly;\n\n        invariant(context.path.pop() === resultName);\n\n      } else {\n        const fragment = getFragmentFromSelection(\n          selection,\n          context.fragmentMap,\n        );\n\n        if (fragment && policies.fragmentMatches(fragment, typename)) {\n          fragment.selectionSet.selections.forEach(workSet.add, workSet);\n        }\n      }\n    });\n\n    // Perform a single merge at the end so that we can avoid making more\n    // defensive shallow copies than necessary.\n    finalResult.result = mergeDeepArray(objectsToMerge);\n\n    if (process.env.NODE_ENV !== 'production') {\n      Object.freeze(finalResult.result);\n    }\n\n    // Store this result with its selection set so that we can quickly\n    // recognize it again in the StoreReader#isFresh method.\n    this.knownResults.set(finalResult.result, selectionSet);\n\n    return finalResult;\n  }\n\n  private knownResults = new WeakMap<Record<string, any>, SelectionSetNode>();\n\n  // Cached version of execSubSelectedArrayImpl.\n  private executeSubSelectedArray = wrap((options: ExecSubSelectedArrayOptions) => {\n    return this.execSubSelectedArrayImpl(options);\n  }, {\n    makeCacheKey({ field, array, context }) {\n      if (supportsResultCaching(context.store)) {\n        return context.store.makeCacheKey(\n          field,\n          array,\n          context.varString,\n        );\n      }\n    }\n  });\n\n  // Uncached version of executeSubSelectedArray.\n  private execSubSelectedArrayImpl({\n    field,\n    array,\n    context,\n  }: ExecSubSelectedArrayOptions): ExecResult {\n    let missing: MissingFieldError[] | undefined;\n\n    function handleMissing<T>(childResult: ExecResult<T>, i: number): T {\n      if (childResult.missing) {\n        missing = missing || [];\n        missing.push(...childResult.missing);\n      }\n\n      invariant(context.path.pop() === i);\n\n      return childResult.result;\n    }\n\n    if (field.selectionSet) {\n      array = array.filter(context.store.canRead);\n    }\n\n    array = array.map((item, i) => {\n      // null value in array\n      if (item === null) {\n        return null;\n      }\n\n      context.path.push(i);\n\n      // This is a nested array, recurse\n      if (Array.isArray(item)) {\n        return handleMissing(this.executeSubSelectedArray({\n          field,\n          array: item,\n          context,\n        }), i);\n      }\n\n      // This is an object, run the selection set on it\n      if (field.selectionSet) {\n        return handleMissing(this.executeSelectionSet({\n          selectionSet: field.selectionSet,\n          objectOrReference: item,\n          context,\n        }), i);\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        assertSelectionSetForIdValue(context.store, field, item);\n      }\n\n      invariant(context.path.pop() === i);\n\n      return item;\n    });\n\n    if (process.env.NODE_ENV !== 'production') {\n      Object.freeze(array);\n    }\n\n    return { result: array, missing };\n  }\n}\n\nfunction assertSelectionSetForIdValue(\n  store: NormalizedCache,\n  field: FieldNode,\n  fieldValue: any,\n) {\n  if (!field.selectionSet) {\n    const workSet = new Set([fieldValue]);\n    workSet.forEach(value => {\n      if (value && typeof value === \"object\") {\n        invariant(\n          !isReference(value),\n          `Missing selection set for object of type ${\n            getTypenameFromStoreObject(store, value)\n          } returned for query field ${field.name.value}`,\n        );\n        Object.values(value).forEach(workSet.add, workSet);\n      }\n    });\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}