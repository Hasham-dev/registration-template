{"ast":null,"code":"import { invariant, InvariantError } from 'ts-invariant';\nimport { valueToObjectRepresentation } from \"./storeUtils.js\";\nexport function checkDocument(doc) {\n  process.env.NODE_ENV === \"production\" ? invariant(doc && doc.kind === 'Document', 45) : invariant(doc && doc.kind === 'Document', \"Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \\\"gql\\\" tag? http://docs.apollostack.com/apollo-client/core.html#gql\");\n  var operations = doc.definitions.filter(function (d) {\n    return d.kind !== 'FragmentDefinition';\n  }).map(function (definition) {\n    if (definition.kind !== 'OperationDefinition') {\n      throw process.env.NODE_ENV === \"production\" ? new InvariantError(46) : new InvariantError(\"Schema type definitions not allowed in queries. Found: \\\"\" + definition.kind + \"\\\"\");\n    }\n    return definition;\n  });\n  process.env.NODE_ENV === \"production\" ? invariant(operations.length <= 1, 47) : invariant(operations.length <= 1, \"Ambiguous GraphQL document: contains \" + operations.length + \" operations\");\n  return doc;\n}\nexport function getOperationDefinition(doc) {\n  checkDocument(doc);\n  return doc.definitions.filter(function (definition) {\n    return definition.kind === 'OperationDefinition';\n  })[0];\n}\nexport function getOperationName(doc) {\n  return doc.definitions.filter(function (definition) {\n    return definition.kind === 'OperationDefinition' && definition.name;\n  }).map(function (x) {\n    return x.name.value;\n  })[0] || null;\n}\nexport function getFragmentDefinitions(doc) {\n  return doc.definitions.filter(function (definition) {\n    return definition.kind === 'FragmentDefinition';\n  });\n}\nexport function getQueryDefinition(doc) {\n  var queryDef = getOperationDefinition(doc);\n  process.env.NODE_ENV === \"production\" ? invariant(queryDef && queryDef.operation === 'query', 48) : invariant(queryDef && queryDef.operation === 'query', 'Must contain a query definition.');\n  return queryDef;\n}\nexport function getFragmentDefinition(doc) {\n  process.env.NODE_ENV === \"production\" ? invariant(doc.kind === 'Document', 49) : invariant(doc.kind === 'Document', \"Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \\\"gql\\\" tag? http://docs.apollostack.com/apollo-client/core.html#gql\");\n  process.env.NODE_ENV === \"production\" ? invariant(doc.definitions.length <= 1, 50) : invariant(doc.definitions.length <= 1, 'Fragment must have exactly one definition.');\n  var fragmentDef = doc.definitions[0];\n  process.env.NODE_ENV === \"production\" ? invariant(fragmentDef.kind === 'FragmentDefinition', 51) : invariant(fragmentDef.kind === 'FragmentDefinition', 'Must be a fragment definition.');\n  return fragmentDef;\n}\nexport function getMainDefinition(queryDoc) {\n  checkDocument(queryDoc);\n  var fragmentDefinition;\n  for (var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++) {\n    var definition = _a[_i];\n    if (definition.kind === 'OperationDefinition') {\n      var operation = definition.operation;\n      if (operation === 'query' || operation === 'mutation' || operation === 'subscription') {\n        return definition;\n      }\n    }\n    if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {\n      fragmentDefinition = definition;\n    }\n  }\n  if (fragmentDefinition) {\n    return fragmentDefinition;\n  }\n  throw process.env.NODE_ENV === \"production\" ? new InvariantError(52) : new InvariantError('Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.');\n}\nexport function getDefaultValues(definition) {\n  var defaultValues = Object.create(null);\n  var defs = definition && definition.variableDefinitions;\n  if (defs && defs.length) {\n    defs.forEach(function (def) {\n      if (def.defaultValue) {\n        valueToObjectRepresentation(defaultValues, def.variable.name, def.defaultValue);\n      }\n    });\n  }\n  return defaultValues;\n}","map":{"version":3,"sources":["../../../src/utilities/graphql/getFromAST.ts"],"names":[],"mappings":"AAOA,SAAS,SAAS,EAAE,cAAc,QAAQ,cAAc;AAExD,SAAS,2BAA2B,QAAQ,iBAAe;AAG3D,OAAM,SAAU,aAAa,CAAC,GAAiB,EAAA;EAC7C,OAAA,CAAA,GACE,CAAA,QAAU,KAAK,YAAK,GAAU,SAC9B,CAAA,GAAA,IAAA,GAAA,CAAA,IAAA,KAAA,UAAA,EAAA,EAAA,CAAA,GAAA,SAAA,CAAA,GAAA,IAAA,GAAA,CAAA,IAAA,KAAA,UAAA,EAAA,0JAEA,CAAA;EAEF,IAAM,UAAU,GAAG,GAAG,CAAC,WAAW,CAC/B,MAAM,CAAC,UAAA,CAAC,EAAA;IAAI,OAAA,CAAC,CAAC,IAAI,KAAK,oBAAoB;EAA/B,CAA+B,CAAC,CAC5C,GAAG,CAAC,UAAA,UAAU,EAAA;IACb,IAAI,UAAU,CAAC,IAAI,KAAK,qBAAqB,EAAE;MAC7C,MAAM,OAAI,CAAA,GAAA,CAAA,QACR,KAAA,YAAA,GAAA,IAAA,cAAA,CAAA,EAAA,CAAA,GAAA,IAAA,cACE,CAAA,2DAEF,GAAA,UAAA,CAAA,IAAA,GAAA,IAAA,CAAA;IACH;IACD,OAAO,UAAU;EACnB,CAAC,CAAC;EAEJ,OAAA,CAAA,GACE,CAAA,QAAU,KAAC,YACX,GAAA,SAAA,CAAA,UAAA,CAAA,MAAA,IAAA,CAAA,EAAA,EAAwC,CAAA,GAAA,SAAW,CAAA,UAAM,CAAA,MAAA,IACzD,CAAA,EAAA,uCAAA,GAAA,UAAA,CAAA,MAAA,GAAA,aAAA,CAAA;EAEF,OAAO,GAAG;AACZ;AAEA,OAAM,SAAU,sBAAsB,CACpC,GAAiB,EAAA;EAEjB,aAAa,CAAC,GAAG,CAAC;EAClB,OAAO,GAAG,CAAC,WAAW,CAAC,MAAM,CAC3B,UAAA,UAAU,EAAA;IAAI,OAAA,UAAU,CAAC,IAAI,KAAK,qBAAqB;EAAzC,CAAyC,CACxD,CAAC,CAAC,CAA4B;AACjC;AAEA,OAAM,SAAU,gBAAgB,CAAC,GAAiB,EAAA;EAChD,OACE,GAAG,CAAC,WAAW,CACZ,MAAM,CACL,UAAA,UAAU,EAAA;IACR,OAAA,UAAU,CAAC,IAAI,KAAK,qBAAqB,IAAI,UAAU,CAAC,IAAI;EAA5D,CAA4D,CAC/D,CACA,GAAG,CAAC,UAAC,CAA0B,EAAA;IAAK,OAAA,CAAE,CAAC,IAAK,CAAC,KAAK;EAAd,CAAc,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI;AAErE;AAGA,OAAM,SAAU,sBAAsB,CACpC,GAAiB,EAAA;EAEjB,OAAO,GAAG,CAAC,WAAW,CAAC,MAAM,CAC3B,UAAA,UAAU,EAAA;IAAI,OAAA,UAAU,CAAC,IAAI,KAAK,oBAAoB;EAAxC,CAAwC,CAC3B;AAC/B;AAEA,OAAM,SAAU,kBAAkB,CAAC,GAAiB,EAAA;EAClD,IAAM,QAAQ,GAAG,sBAAsB,CAAC,GAAG,CAA4B;EAEvE,OAAA,CAAA,GACE,CAAA,QAAQ,KAAI,YAAS,GAAS,SAAK,CAAA,QACnC,IAAA,QAAA,CAAA,SAAA,KAAA,OACA,EAAA,EAAA,CAAA,GAAA,SAAA,CAAA,QAAA,IAAA,QAAA,CAAA,SAAA,KAAA,OAAA,EAAA,kCAAA,CAAA;EAEF,OAAO,QAAQ;AACjB;AAEA,OAAM,SAAU,qBAAqB,CACnC,GAAiB,EAAA;EAEjB,OAAA,CAAA,GACE,CAAA,QAAQ,KAAK,YACb,GAAA,SAAA,CAAA,GAAA,CAAA,IAAA,KAAA,UAAA,EAAA,EAAA,CAAA,GAAA,SAAA,CAAA,GAAA,CAAA,IAAA,KAAA,UAAA,EAAA,0JAEA,CAAA;EAEF,OAAA,CAAA,GACE,CAAA,QAAI,KAAW,YAAY,GAC3B,SAAA,CAAA,GAAA,CAAA,WAAA,CAAA,MAAA,IAAA,CAAA,EAAA,EAAA,CAAA,GACA,SAAA,CAAA,GAAA,CAAA,WAAA,CAAA,MAAA,IAAA,CAAA,EAAA,4CAAA,CAAA;EAEF,IAAM,WAAW,GAAG,GAAG,CAAC,WAAW,CAAC,CAAC,CAA2B;EAEhE,OAAA,CAAA,GACE,CAAA,QAAA,KAAY,YAAS,GAAA,SAAA,CAAA,WACrB,CAAA,IAAA,KAAA,oBACA,EAAA,EAAA,CAAA,GAAA,SAAA,CAAA,WAAA,CAAA,IAAA,KAAA,oBAAA,EAAA,gCAAA,CAAA;EAEF,OAAO,WAAqC;AAC9C;AAOA,OAAM,SAAU,iBAAiB,CAC/B,QAAsB,EAAA;EAEtB,aAAa,CAAC,QAAQ,CAAC;EAEvB,IAAI,kBAAkB;EAEtB,KAAuB,IAAA,EAAA,GAAA,CAAoB,EAApB,EAAA,GAAA,QAAQ,CAAC,WAAW,EAApB,EAAA,GAAA,EAAA,CAAA,MAAoB,EAApB,EAAA,EAAoB,EAAE;IAAxC,IAAI,UAAU,GAAA,EAAA,CAAA,EAAA,CAAA;IACjB,IAAI,UAAU,CAAC,IAAI,KAAK,qBAAqB,EAAE;MAC7C,IAAM,SAAS,GAAI,UAAsC,CAAC,SAAS;MACnE,IACE,SAAS,KAAK,OAAO,IACrB,SAAS,KAAK,UAAU,IACxB,SAAS,KAAK,cAAc,EAC5B;QACA,OAAO,UAAqC;MAC7C;IACF;IACD,IAAI,UAAU,CAAC,IAAI,KAAK,oBAAoB,IAAI,CAAC,kBAAkB,EAAE;MAGnE,kBAAkB,GAAG,UAAoC;IAC1D;EACF;EAED,IAAI,kBAAkB,EAAE;IACtB,OAAO,kBAAkB;EAC1B;EAED,MAAM,OAAI,CAAA,GAAA,CAAA,QACR,KAAA,YAAA,GAAA,IAAA,cAAA,CAAA,EAAA,CAAA,GAAA,IAAA,cAAA,CAAA,sFACA,CAAA;AACJ;AAEA,OAAM,SAAU,gBAAgB,CAC9B,UAA+C,EAAA;EAE/C,IAAM,aAAa,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC;EACzC,IAAM,IAAI,GAAG,UAAU,IAAI,UAAU,CAAC,mBAAmB;EACzD,IAAI,IAAI,IAAI,IAAI,CAAC,MAAM,EAAE;IACvB,IAAI,CAAC,OAAO,CAAC,UAAA,GAAG,EAAA;MACd,IAAI,GAAG,CAAC,YAAY,EAAE;QACpB,2BAA2B,CACzB,aAAa,EACb,GAAG,CAAC,QAAQ,CAAC,IAAI,EACjB,GAAG,CAAC,YAAyB,CAC9B;MACF;IACH,CAAC,CAAC;EACH;EACD,OAAO,aAAa;AACtB","sourcesContent":["import {\n  DocumentNode,\n  OperationDefinitionNode,\n  FragmentDefinitionNode,\n  ValueNode,\n} from 'graphql';\n\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport { valueToObjectRepresentation } from './storeUtils';\n\n// Checks the document for errors and throws an exception if there is an error.\nexport function checkDocument(doc: DocumentNode) {\n  invariant(\n    doc && doc.kind === 'Document',\n    `Expecting a parsed GraphQL document. Perhaps you need to wrap the query \\\nstring in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql`,\n  );\n\n  const operations = doc.definitions\n    .filter(d => d.kind !== 'FragmentDefinition')\n    .map(definition => {\n      if (definition.kind !== 'OperationDefinition') {\n        throw new InvariantError(\n          `Schema type definitions not allowed in queries. Found: \"${\n            definition.kind\n          }\"`,\n        );\n      }\n      return definition;\n    });\n\n  invariant(\n    operations.length <= 1,\n    `Ambiguous GraphQL document: contains ${operations.length} operations`,\n  );\n\n  return doc;\n}\n\nexport function getOperationDefinition(\n  doc: DocumentNode,\n): OperationDefinitionNode | undefined {\n  checkDocument(doc);\n  return doc.definitions.filter(\n    definition => definition.kind === 'OperationDefinition',\n  )[0] as OperationDefinitionNode;\n}\n\nexport function getOperationName(doc: DocumentNode): string | null {\n  return (\n    doc.definitions\n      .filter(\n        definition =>\n          definition.kind === 'OperationDefinition' && definition.name,\n      )\n      .map((x: OperationDefinitionNode) => x!.name!.value)[0] || null\n  );\n}\n\n// Returns the FragmentDefinitions from a particular document as an array\nexport function getFragmentDefinitions(\n  doc: DocumentNode,\n): FragmentDefinitionNode[] {\n  return doc.definitions.filter(\n    definition => definition.kind === 'FragmentDefinition',\n  ) as FragmentDefinitionNode[];\n}\n\nexport function getQueryDefinition(doc: DocumentNode): OperationDefinitionNode {\n  const queryDef = getOperationDefinition(doc) as OperationDefinitionNode;\n\n  invariant(\n    queryDef && queryDef.operation === 'query',\n    'Must contain a query definition.',\n  );\n\n  return queryDef;\n}\n\nexport function getFragmentDefinition(\n  doc: DocumentNode,\n): FragmentDefinitionNode {\n  invariant(\n    doc.kind === 'Document',\n    `Expecting a parsed GraphQL document. Perhaps you need to wrap the query \\\nstring in a \"gql\" tag? http://docs.apollostack.com/apollo-client/core.html#gql`,\n  );\n\n  invariant(\n    doc.definitions.length <= 1,\n    'Fragment must have exactly one definition.',\n  );\n\n  const fragmentDef = doc.definitions[0] as FragmentDefinitionNode;\n\n  invariant(\n    fragmentDef.kind === 'FragmentDefinition',\n    'Must be a fragment definition.',\n  );\n\n  return fragmentDef as FragmentDefinitionNode;\n}\n\n/**\n * Returns the first operation definition found in this document.\n * If no operation definition is found, the first fragment definition will be returned.\n * If no definitions are found, an error will be thrown.\n */\nexport function getMainDefinition(\n  queryDoc: DocumentNode,\n): OperationDefinitionNode | FragmentDefinitionNode {\n  checkDocument(queryDoc);\n\n  let fragmentDefinition;\n\n  for (let definition of queryDoc.definitions) {\n    if (definition.kind === 'OperationDefinition') {\n      const operation = (definition as OperationDefinitionNode).operation;\n      if (\n        operation === 'query' ||\n        operation === 'mutation' ||\n        operation === 'subscription'\n      ) {\n        return definition as OperationDefinitionNode;\n      }\n    }\n    if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {\n      // we do this because we want to allow multiple fragment definitions\n      // to precede an operation definition.\n      fragmentDefinition = definition as FragmentDefinitionNode;\n    }\n  }\n\n  if (fragmentDefinition) {\n    return fragmentDefinition;\n  }\n\n  throw new InvariantError(\n    'Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.',\n  );\n}\n\nexport function getDefaultValues(\n  definition: OperationDefinitionNode | undefined,\n): Record<string, any> {\n  const defaultValues = Object.create(null);\n  const defs = definition && definition.variableDefinitions;\n  if (defs && defs.length) {\n    defs.forEach(def => {\n      if (def.defaultValue) {\n        valueToObjectRepresentation(\n          defaultValues,\n          def.variable.name,\n          def.defaultValue as ValueNode,\n        );\n      }\n    });\n  }\n  return defaultValues;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}