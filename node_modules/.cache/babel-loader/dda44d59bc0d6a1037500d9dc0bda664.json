{"ast":null,"code":"import { isReference, isField, DeepMerger, resultKeyNameFromField, shouldInclude } from \"../../utilities/index.js\";\nexport var hasOwn = Object.prototype.hasOwnProperty;\nexport function getTypenameFromStoreObject(store, objectOrReference) {\n  return isReference(objectOrReference) ? store.get(objectOrReference.__ref, \"__typename\") : objectOrReference && objectOrReference.__typename;\n}\nexport var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\nexport function fieldNameFromStoreName(storeFieldName) {\n  var match = storeFieldName.match(TypeOrFieldNameRegExp);\n  return match ? match[0] : storeFieldName;\n}\nexport function selectionSetMatchesResult(selectionSet, result, variables) {\n  if (result && typeof result === \"object\") {\n    return Array.isArray(result) ? result.every(function (item) {\n      return selectionSetMatchesResult(selectionSet, item, variables);\n    }) : selectionSet.selections.every(function (field) {\n      if (isField(field) && shouldInclude(field, variables)) {\n        var key = resultKeyNameFromField(field);\n        return hasOwn.call(result, key) && (!field.selectionSet || selectionSetMatchesResult(field.selectionSet, result[key], variables));\n      }\n      return true;\n    });\n  }\n  return false;\n}\nexport function storeValueIsStoreObject(value) {\n  return value !== null && typeof value === \"object\" && !isReference(value) && !Array.isArray(value);\n}\nexport function makeProcessedFieldsMerger() {\n  return new DeepMerger();\n}","map":{"version":3,"sources":["../../../src/cache/inmemory/helpers.ts"],"names":[],"mappings":"AAGA,SAEE,WAAW,EAGX,OAAO,EACP,UAAU,EACV,sBAAsB,EACtB,aAAa,QACR,0BAAkB;AAEzB,OAAO,IAAM,MAAM,GAAG,MAAM,CAAC,SAAS,CAAC,cAAc;AAErD,OAAM,SAAU,0BAA0B,CACxC,KAAsB,EACtB,iBAA0C,EAAA;EAE1C,OAAO,WAAW,CAAC,iBAAiB,CAAC,GACjC,KAAK,CAAC,GAAG,CAAC,iBAAiB,CAAC,KAAK,EAAE,YAAY,CAAW,GAC1D,iBAAiB,IAAI,iBAAiB,CAAC,UAAU;AACvD;AAEA,OAAO,IAAM,qBAAqB,GAAG,oBAAoB;AAEzD,OAAM,SAAU,sBAAsB,CAAC,cAAsB,EAAA;EAC3D,IAAM,KAAK,GAAG,cAAc,CAAC,KAAK,CAAC,qBAAqB,CAAC;EACzD,OAAO,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,GAAG,cAAc;AAC1C;AAEA,OAAM,SAAU,yBAAyB,CACvC,YAA8B,EAC9B,MAA2B,EAC3B,SAA+B,EAAA;EAE/B,IAAI,MAAM,IAAI,OAAO,MAAM,KAAK,QAAQ,EAAE;IACxC,OAAO,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,GACxB,MAAM,CAAC,KAAK,CAAC,UAAA,IAAI,EAAA;MAAI,OAAA,yBAAyB,CAAC,YAAY,EAAE,IAAI,EAAE,SAAS,CAAC;IAAxD,CAAwD,CAAC,GAC9E,YAAY,CAAC,UAAU,CAAC,KAAK,CAAC,UAAA,KAAK,EAAA;MACnC,IAAI,OAAO,CAAC,KAAK,CAAC,IAAI,aAAa,CAAC,KAAK,EAAE,SAAS,CAAC,EAAE;QACrD,IAAM,GAAG,GAAG,sBAAsB,CAAC,KAAK,CAAC;QACzC,OAAO,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC,KAC5B,CAAC,KAAK,CAAC,YAAY,IACnB,yBAAyB,CAAC,KAAK,CAAC,YAAY,EAAE,MAAM,CAAC,GAAG,CAAC,EAAE,SAAS,CAAC,CAAC;MAC1E;MAMD,OAAO,IAAI;IACb,CAAC,CAAC;EACL;EACD,OAAO,KAAK;AACd;AAEA,OAAM,SAAU,uBAAuB,CACrC,KAAiB,EAAA;EAEjB,OAAO,KAAK,KAAK,IAAI,IACnB,OAAO,KAAK,KAAK,QAAQ,IACzB,CAAC,WAAW,CAAC,KAAK,CAAC,IACnB,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC;AACzB;AAEA,OAAM,SAAU,yBAAyB,GAAA;EACvC,OAAO,IAAI,UAAU;AACvB","sourcesContent":["import { SelectionSetNode } from 'graphql';\n\nimport { NormalizedCache } from './types';\nimport {\n  Reference,\n  isReference,\n  StoreValue,\n  StoreObject,\n  isField,\n  DeepMerger,\n  resultKeyNameFromField,\n  shouldInclude,\n} from '../../utilities';\n\nexport const hasOwn = Object.prototype.hasOwnProperty;\n\nexport function getTypenameFromStoreObject(\n  store: NormalizedCache,\n  objectOrReference: StoreObject | Reference,\n): string | undefined {\n  return isReference(objectOrReference)\n    ? store.get(objectOrReference.__ref, \"__typename\") as string\n    : objectOrReference && objectOrReference.__typename;\n}\n\nexport const TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\n\nexport function fieldNameFromStoreName(storeFieldName: string): string {\n  const match = storeFieldName.match(TypeOrFieldNameRegExp);\n  return match ? match[0] : storeFieldName;\n}\n\nexport function selectionSetMatchesResult(\n  selectionSet: SelectionSetNode,\n  result: Record<string, any>,\n  variables?: Record<string, any>,\n): boolean {\n  if (result && typeof result === \"object\") {\n    return Array.isArray(result)\n      ? result.every(item => selectionSetMatchesResult(selectionSet, item, variables))\n      : selectionSet.selections.every(field => {\n        if (isField(field) && shouldInclude(field, variables)) {\n          const key = resultKeyNameFromField(field);\n          return hasOwn.call(result, key) &&\n            (!field.selectionSet ||\n             selectionSetMatchesResult(field.selectionSet, result[key], variables));\n        }\n        // If the selection has been skipped with @skip(true) or\n        // @include(false), it should not count against the matching. If\n        // the selection is not a field, it must be a fragment (inline or\n        // named). We will determine if selectionSetMatchesResult for that\n        // fragment when we get to it, so for now we return true.\n        return true;\n      });\n  }\n  return false;\n}\n\nexport function storeValueIsStoreObject(\n  value: StoreValue,\n): value is StoreObject {\n  return value !== null &&\n    typeof value === \"object\" &&\n    !isReference(value) &&\n    !Array.isArray(value);\n}\n\nexport function makeProcessedFieldsMerger() {\n  return new DeepMerger;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}