{"ast":null,"code":"import { __assign, __awaiter, __generator } from \"tslib\";\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { equal } from '@wry/equality';\nimport { execute } from \"../link/core/index.js\";\nimport { getDefaultValues, getOperationDefinition, getOperationName, hasClientExports, graphQLResultHasError, removeConnectionDirectiveFromDocument, canUseWeakMap, Observable, asyncMap, isNonEmptyArray, Concast } from \"../utilities/index.js\";\nimport { ApolloError, isApolloError } from \"../errors/index.js\";\nimport { ObservableQuery } from \"./ObservableQuery.js\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport { LocalState } from \"./LocalState.js\";\nimport { QueryInfo, shouldWriteResult } from \"./QueryInfo.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar QueryManager = function () {\n  function QueryManager(_a) {\n    var cache = _a.cache,\n      link = _a.link,\n      _b = _a.queryDeduplication,\n      queryDeduplication = _b === void 0 ? false : _b,\n      onBroadcast = _a.onBroadcast,\n      _c = _a.ssrMode,\n      ssrMode = _c === void 0 ? false : _c,\n      _d = _a.clientAwareness,\n      clientAwareness = _d === void 0 ? {} : _d,\n      localState = _a.localState,\n      assumeImmutableResults = _a.assumeImmutableResults;\n    this.clientAwareness = {};\n    this.queries = new Map();\n    this.fetchCancelFns = new Map();\n    this.transformCache = new (canUseWeakMap ? WeakMap : Map)();\n    this.queryIdCounter = 1;\n    this.requestIdCounter = 1;\n    this.mutationIdCounter = 1;\n    this.inFlightLinkObservables = new Map();\n    this.cache = cache;\n    this.link = link;\n    this.queryDeduplication = queryDeduplication;\n    this.clientAwareness = clientAwareness;\n    this.localState = localState || new LocalState({\n      cache: cache\n    });\n    this.ssrMode = ssrMode;\n    this.assumeImmutableResults = !!assumeImmutableResults;\n    if (this.onBroadcast = onBroadcast) {\n      this.mutationStore = Object.create(null);\n    }\n  }\n  QueryManager.prototype.stop = function () {\n    var _this = this;\n    this.queries.forEach(function (_info, queryId) {\n      _this.stopQueryNoBroadcast(queryId);\n    });\n    this.cancelPendingFetches(process.env.NODE_ENV === \"production\" ? new InvariantError(12) : new InvariantError('QueryManager stopped while query was in flight'));\n  };\n  QueryManager.prototype.cancelPendingFetches = function (error) {\n    this.fetchCancelFns.forEach(function (cancel) {\n      return cancel(error);\n    });\n    this.fetchCancelFns.clear();\n  };\n  QueryManager.prototype.mutate = function (_a) {\n    var mutation = _a.mutation,\n      variables = _a.variables,\n      optimisticResponse = _a.optimisticResponse,\n      updateQueries = _a.updateQueries,\n      _b = _a.refetchQueries,\n      refetchQueries = _b === void 0 ? [] : _b,\n      _c = _a.awaitRefetchQueries,\n      awaitRefetchQueries = _c === void 0 ? false : _c,\n      updateWithProxyFn = _a.update,\n      _d = _a.errorPolicy,\n      errorPolicy = _d === void 0 ? 'none' : _d,\n      fetchPolicy = _a.fetchPolicy,\n      _e = _a.context,\n      context = _e === void 0 ? {} : _e;\n    return __awaiter(this, void 0, void 0, function () {\n      var mutationId, mutationStoreValue, self;\n      return __generator(this, function (_f) {\n        switch (_f.label) {\n          case 0:\n            process.env.NODE_ENV === \"production\" ? invariant(mutation, 13) : invariant(mutation, 'mutation option is required. You must specify your GraphQL document in the mutation option.');\n            process.env.NODE_ENV === \"production\" ? invariant(!fetchPolicy || fetchPolicy === 'no-cache', 14) : invariant(!fetchPolicy || fetchPolicy === 'no-cache', \"Mutations only support a 'no-cache' fetchPolicy. If you don't want to disable the cache, remove your fetchPolicy setting to proceed with the default mutation behavior.\");\n            mutationId = this.generateMutationId();\n            mutation = this.transform(mutation).document;\n            variables = this.getVariables(mutation, variables);\n            if (!this.transform(mutation).hasClientExports) return [3, 2];\n            return [4, this.localState.addExportedVariables(mutation, variables, context)];\n          case 1:\n            variables = _f.sent();\n            _f.label = 2;\n          case 2:\n            mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {\n              mutation: mutation,\n              variables: variables,\n              loading: true,\n              error: null\n            });\n            if (optimisticResponse) {\n              this.markMutationOptimistic(optimisticResponse, {\n                mutationId: mutationId,\n                document: mutation,\n                variables: variables,\n                errorPolicy: errorPolicy,\n                updateQueries: updateQueries,\n                update: updateWithProxyFn\n              });\n            }\n            this.broadcastQueries();\n            self = this;\n            return [2, new Promise(function (resolve, reject) {\n              var storeResult;\n              var error;\n              self.getObservableFromLink(mutation, __assign(__assign({}, context), {\n                optimisticResponse: optimisticResponse\n              }), variables, false).subscribe({\n                next: function next(result) {\n                  if (graphQLResultHasError(result) && errorPolicy === 'none') {\n                    error = new ApolloError({\n                      graphQLErrors: result.errors\n                    });\n                    return;\n                  }\n                  if (mutationStoreValue) {\n                    mutationStoreValue.loading = false;\n                    mutationStoreValue.error = null;\n                  }\n                  if (fetchPolicy !== 'no-cache') {\n                    try {\n                      self.markMutationResult({\n                        mutationId: mutationId,\n                        result: result,\n                        document: mutation,\n                        variables: variables,\n                        errorPolicy: errorPolicy,\n                        updateQueries: updateQueries,\n                        update: updateWithProxyFn\n                      });\n                    } catch (e) {\n                      error = new ApolloError({\n                        networkError: e\n                      });\n                      return;\n                    }\n                  }\n                  storeResult = result;\n                },\n                error: function error(err) {\n                  if (mutationStoreValue) {\n                    mutationStoreValue.loading = false;\n                    mutationStoreValue.error = err;\n                  }\n                  if (optimisticResponse) {\n                    self.cache.removeOptimistic(mutationId);\n                  }\n                  self.broadcastQueries();\n                  reject(new ApolloError({\n                    networkError: err\n                  }));\n                },\n                complete: function complete() {\n                  if (error && mutationStoreValue) {\n                    mutationStoreValue.loading = false;\n                    mutationStoreValue.error = error;\n                  }\n                  if (optimisticResponse) {\n                    self.cache.removeOptimistic(mutationId);\n                  }\n                  self.broadcastQueries();\n                  if (error) {\n                    reject(error);\n                    return;\n                  }\n                  if (typeof refetchQueries === 'function') {\n                    refetchQueries = refetchQueries(storeResult);\n                  }\n                  var refetchQueryPromises = [];\n                  if (isNonEmptyArray(refetchQueries)) {\n                    refetchQueries.forEach(function (refetchQuery) {\n                      if (typeof refetchQuery === 'string') {\n                        self.queries.forEach(function (_a) {\n                          var observableQuery = _a.observableQuery;\n                          if (observableQuery && observableQuery.hasObservers() && observableQuery.queryName === refetchQuery) {\n                            refetchQueryPromises.push(observableQuery.refetch());\n                          }\n                        });\n                      } else {\n                        var queryOptions = {\n                          query: refetchQuery.query,\n                          variables: refetchQuery.variables,\n                          fetchPolicy: 'network-only'\n                        };\n                        if (refetchQuery.context) {\n                          queryOptions.context = refetchQuery.context;\n                        }\n                        refetchQueryPromises.push(self.query(queryOptions));\n                      }\n                    });\n                  }\n                  Promise.all(awaitRefetchQueries ? refetchQueryPromises : []).then(function () {\n                    if (errorPolicy === 'ignore' && storeResult && graphQLResultHasError(storeResult)) {\n                      delete storeResult.errors;\n                    }\n                    resolve(storeResult);\n                  }, reject);\n                }\n              });\n            })];\n        }\n      });\n    });\n  };\n  QueryManager.prototype.markMutationResult = function (mutation, cache) {\n    var _this = this;\n    if (cache === void 0) {\n      cache = this.cache;\n    }\n    if (shouldWriteResult(mutation.result, mutation.errorPolicy)) {\n      var cacheWrites_1 = [{\n        result: mutation.result.data,\n        dataId: 'ROOT_MUTATION',\n        query: mutation.document,\n        variables: mutation.variables\n      }];\n      var updateQueries_1 = mutation.updateQueries;\n      if (updateQueries_1) {\n        this.queries.forEach(function (_a, queryId) {\n          var observableQuery = _a.observableQuery;\n          var queryName = observableQuery && observableQuery.queryName;\n          if (!queryName || !hasOwnProperty.call(updateQueries_1, queryName)) {\n            return;\n          }\n          var updater = updateQueries_1[queryName];\n          var _b = _this.queries.get(queryId),\n            document = _b.document,\n            variables = _b.variables;\n          var _c = cache.diff({\n              query: document,\n              variables: variables,\n              returnPartialData: true,\n              optimistic: false\n            }),\n            currentQueryResult = _c.result,\n            complete = _c.complete;\n          if (complete && currentQueryResult) {\n            var nextQueryResult = updater(currentQueryResult, {\n              mutationResult: mutation.result,\n              queryName: document && getOperationName(document) || void 0,\n              queryVariables: variables\n            });\n            if (nextQueryResult) {\n              cacheWrites_1.push({\n                result: nextQueryResult,\n                dataId: 'ROOT_QUERY',\n                query: document,\n                variables: variables\n              });\n            }\n          }\n        });\n      }\n      cache.performTransaction(function (c) {\n        cacheWrites_1.forEach(function (write) {\n          return c.write(write);\n        });\n        var update = mutation.update;\n        if (update) {\n          update(c, mutation.result);\n        }\n      }, null);\n    }\n  };\n  QueryManager.prototype.markMutationOptimistic = function (optimisticResponse, mutation) {\n    var _this = this;\n    var data = typeof optimisticResponse === \"function\" ? optimisticResponse(mutation.variables) : optimisticResponse;\n    return this.cache.recordOptimisticTransaction(function (cache) {\n      try {\n        _this.markMutationResult(__assign(__assign({}, mutation), {\n          result: {\n            data: data\n          }\n        }), cache);\n      } catch (error) {\n        process.env.NODE_ENV === \"production\" || invariant.error(error);\n      }\n    }, mutation.mutationId);\n  };\n  QueryManager.prototype.fetchQuery = function (queryId, options, networkStatus) {\n    return this.fetchQueryObservable(queryId, options, networkStatus).promise;\n  };\n  QueryManager.prototype.getQueryStore = function () {\n    var store = Object.create(null);\n    this.queries.forEach(function (info, queryId) {\n      store[queryId] = {\n        variables: info.variables,\n        networkStatus: info.networkStatus,\n        networkError: info.networkError,\n        graphQLErrors: info.graphQLErrors\n      };\n    });\n    return store;\n  };\n  QueryManager.prototype.resetErrors = function (queryId) {\n    var queryInfo = this.queries.get(queryId);\n    if (queryInfo) {\n      queryInfo.networkError = undefined;\n      queryInfo.graphQLErrors = [];\n    }\n  };\n  QueryManager.prototype.transform = function (document) {\n    var transformCache = this.transformCache;\n    if (!transformCache.has(document)) {\n      var transformed = this.cache.transformDocument(document);\n      var forLink = removeConnectionDirectiveFromDocument(this.cache.transformForLink(transformed));\n      var clientQuery = this.localState.clientQuery(transformed);\n      var serverQuery = forLink && this.localState.serverQuery(forLink);\n      var cacheEntry_1 = {\n        document: transformed,\n        hasClientExports: hasClientExports(transformed),\n        hasForcedResolvers: this.localState.shouldForceResolvers(transformed),\n        clientQuery: clientQuery,\n        serverQuery: serverQuery,\n        defaultVars: getDefaultValues(getOperationDefinition(transformed))\n      };\n      var add = function add(doc) {\n        if (doc && !transformCache.has(doc)) {\n          transformCache.set(doc, cacheEntry_1);\n        }\n      };\n      add(document);\n      add(transformed);\n      add(clientQuery);\n      add(serverQuery);\n    }\n    return transformCache.get(document);\n  };\n  QueryManager.prototype.getVariables = function (document, variables) {\n    return __assign(__assign({}, this.transform(document).defaultVars), variables);\n  };\n  QueryManager.prototype.watchQuery = function (options) {\n    options = __assign(__assign({}, options), {\n      variables: this.getVariables(options.query, options.variables)\n    });\n    if (typeof options.notifyOnNetworkStatusChange === 'undefined') {\n      options.notifyOnNetworkStatusChange = false;\n    }\n    var queryInfo = new QueryInfo(this.cache);\n    var observable = new ObservableQuery({\n      queryManager: this,\n      queryInfo: queryInfo,\n      options: options\n    });\n    this.queries.set(observable.queryId, queryInfo);\n    queryInfo.init({\n      document: options.query,\n      observableQuery: observable,\n      variables: options.variables\n    });\n    return observable;\n  };\n  QueryManager.prototype.query = function (options) {\n    var _this = this;\n    process.env.NODE_ENV === \"production\" ? invariant(options.query, 15) : invariant(options.query, 'query option is required. You must specify your GraphQL document ' + 'in the query option.');\n    process.env.NODE_ENV === \"production\" ? invariant(options.query.kind === 'Document', 16) : invariant(options.query.kind === 'Document', 'You must wrap the query string in a \"gql\" tag.');\n    process.env.NODE_ENV === \"production\" ? invariant(!options.returnPartialData, 17) : invariant(!options.returnPartialData, 'returnPartialData option only supported on watchQuery.');\n    process.env.NODE_ENV === \"production\" ? invariant(!options.pollInterval, 18) : invariant(!options.pollInterval, 'pollInterval option only supported on watchQuery.');\n    var queryId = this.generateQueryId();\n    return this.fetchQuery(queryId, options).finally(function () {\n      return _this.stopQuery(queryId);\n    });\n  };\n  QueryManager.prototype.generateQueryId = function () {\n    return String(this.queryIdCounter++);\n  };\n  QueryManager.prototype.generateRequestId = function () {\n    return this.requestIdCounter++;\n  };\n  QueryManager.prototype.generateMutationId = function () {\n    return String(this.mutationIdCounter++);\n  };\n  QueryManager.prototype.stopQueryInStore = function (queryId) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  };\n  QueryManager.prototype.stopQueryInStoreNoBroadcast = function (queryId) {\n    var queryInfo = this.queries.get(queryId);\n    if (queryInfo) queryInfo.stop();\n  };\n  QueryManager.prototype.clearStore = function () {\n    this.cancelPendingFetches(process.env.NODE_ENV === \"production\" ? new InvariantError(19) : new InvariantError('Store reset while query was in flight (not completed in link chain)'));\n    this.queries.forEach(function (queryInfo) {\n      if (queryInfo.observableQuery) {\n        queryInfo.networkStatus = NetworkStatus.loading;\n      } else {\n        queryInfo.stop();\n      }\n    });\n    if (this.mutationStore) {\n      this.mutationStore = Object.create(null);\n    }\n    return this.cache.reset();\n  };\n  QueryManager.prototype.resetStore = function () {\n    var _this = this;\n    return this.clearStore().then(function () {\n      return _this.reFetchObservableQueries();\n    });\n  };\n  QueryManager.prototype.reFetchObservableQueries = function (includeStandby) {\n    var _this = this;\n    if (includeStandby === void 0) {\n      includeStandby = false;\n    }\n    var observableQueryPromises = [];\n    this.queries.forEach(function (_a, queryId) {\n      var observableQuery = _a.observableQuery;\n      if (observableQuery && observableQuery.hasObservers()) {\n        var fetchPolicy = observableQuery.options.fetchPolicy;\n        observableQuery.resetLastResults();\n        if (fetchPolicy !== 'cache-only' && (includeStandby || fetchPolicy !== 'standby')) {\n          observableQueryPromises.push(observableQuery.refetch());\n        }\n        _this.getQuery(queryId).setDiff(null);\n      }\n    });\n    this.broadcastQueries();\n    return Promise.all(observableQueryPromises);\n  };\n  QueryManager.prototype.setObservableQuery = function (observableQuery) {\n    this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);\n  };\n  QueryManager.prototype.startGraphQLSubscription = function (_a) {\n    var _this = this;\n    var query = _a.query,\n      fetchPolicy = _a.fetchPolicy,\n      errorPolicy = _a.errorPolicy,\n      variables = _a.variables,\n      _b = _a.context,\n      context = _b === void 0 ? {} : _b;\n    query = this.transform(query).document;\n    variables = this.getVariables(query, variables);\n    var makeObservable = function makeObservable(variables) {\n      return _this.getObservableFromLink(query, context, variables, false).map(function (result) {\n        if (fetchPolicy !== 'no-cache') {\n          if (shouldWriteResult(result, errorPolicy)) {\n            _this.cache.write({\n              query: query,\n              result: result.data,\n              dataId: 'ROOT_SUBSCRIPTION',\n              variables: variables\n            });\n          }\n          _this.broadcastQueries();\n        }\n        if (graphQLResultHasError(result)) {\n          throw new ApolloError({\n            graphQLErrors: result.errors\n          });\n        }\n        return result;\n      });\n    };\n    if (this.transform(query).hasClientExports) {\n      var observablePromise_1 = this.localState.addExportedVariables(query, variables, context).then(makeObservable);\n      return new Observable(function (observer) {\n        var sub = null;\n        observablePromise_1.then(function (observable) {\n          return sub = observable.subscribe(observer);\n        }, observer.error);\n        return function () {\n          return sub && sub.unsubscribe();\n        };\n      });\n    }\n    return makeObservable(variables);\n  };\n  QueryManager.prototype.stopQuery = function (queryId) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  };\n  QueryManager.prototype.stopQueryNoBroadcast = function (queryId) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  };\n  QueryManager.prototype.removeQuery = function (queryId) {\n    this.fetchCancelFns.delete(queryId);\n    this.getQuery(queryId).stop();\n    this.queries.delete(queryId);\n  };\n  QueryManager.prototype.broadcastQueries = function () {\n    if (this.onBroadcast) this.onBroadcast();\n    this.queries.forEach(function (info) {\n      return info.notify();\n    });\n  };\n  QueryManager.prototype.getLocalState = function () {\n    return this.localState;\n  };\n  QueryManager.prototype.getObservableFromLink = function (query, context, variables, deduplication) {\n    var _this = this;\n    var _a;\n    if (deduplication === void 0) {\n      deduplication = (_a = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a !== void 0 ? _a : this.queryDeduplication;\n    }\n    var observable;\n    var serverQuery = this.transform(query).serverQuery;\n    if (serverQuery) {\n      var _b = this,\n        inFlightLinkObservables_1 = _b.inFlightLinkObservables,\n        link = _b.link;\n      var operation = {\n        query: serverQuery,\n        variables: variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext(__assign(__assign({}, context), {\n          forceFetch: !deduplication\n        }))\n      };\n      context = operation.context;\n      if (deduplication) {\n        var byVariables_1 = inFlightLinkObservables_1.get(serverQuery) || new Map();\n        inFlightLinkObservables_1.set(serverQuery, byVariables_1);\n        var varJson_1 = JSON.stringify(variables);\n        observable = byVariables_1.get(varJson_1);\n        if (!observable) {\n          var concast = new Concast([execute(link, operation)]);\n          byVariables_1.set(varJson_1, observable = concast);\n          concast.cleanup(function () {\n            if (byVariables_1.delete(varJson_1) && byVariables_1.size < 1) {\n              inFlightLinkObservables_1.delete(serverQuery);\n            }\n          });\n        }\n      } else {\n        observable = new Concast([execute(link, operation)]);\n      }\n    } else {\n      observable = new Concast([Observable.of({\n        data: {}\n      })]);\n      context = this.prepareContext(context);\n    }\n    var clientQuery = this.transform(query).clientQuery;\n    if (clientQuery) {\n      observable = asyncMap(observable, function (result) {\n        return _this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context: context,\n          variables: variables\n        });\n      });\n    }\n    return observable;\n  };\n  QueryManager.prototype.getResultsFromLink = function (queryInfo, allowCacheWrite, options) {\n    var lastRequestId = queryInfo.lastRequestId;\n    return asyncMap(this.getObservableFromLink(queryInfo.document, options.context, options.variables), function (result) {\n      var hasErrors = isNonEmptyArray(result.errors);\n      if (lastRequestId >= queryInfo.lastRequestId) {\n        if (hasErrors && options.errorPolicy === \"none\") {\n          throw queryInfo.markError(new ApolloError({\n            graphQLErrors: result.errors\n          }));\n        }\n        queryInfo.markResult(result, options, allowCacheWrite);\n        queryInfo.markReady();\n      }\n      var aqr = {\n        data: result.data,\n        loading: false,\n        networkStatus: queryInfo.networkStatus || NetworkStatus.ready\n      };\n      if (hasErrors && options.errorPolicy !== \"ignore\") {\n        aqr.errors = result.errors;\n      }\n      return aqr;\n    }, function (networkError) {\n      var error = isApolloError(networkError) ? networkError : new ApolloError({\n        networkError: networkError\n      });\n      if (lastRequestId >= queryInfo.lastRequestId) {\n        queryInfo.markError(error);\n      }\n      throw error;\n    });\n  };\n  QueryManager.prototype.fetchQueryObservable = function (queryId, options, networkStatus) {\n    var _this = this;\n    if (networkStatus === void 0) {\n      networkStatus = NetworkStatus.loading;\n    }\n    var query = this.transform(options.query).document;\n    var variables = this.getVariables(query, options.variables);\n    var queryInfo = this.getQuery(queryId);\n    var oldNetworkStatus = queryInfo.networkStatus;\n    var _a = options.fetchPolicy,\n      fetchPolicy = _a === void 0 ? \"cache-first\" : _a,\n      _b = options.errorPolicy,\n      errorPolicy = _b === void 0 ? \"none\" : _b,\n      _c = options.returnPartialData,\n      returnPartialData = _c === void 0 ? false : _c,\n      _d = options.notifyOnNetworkStatusChange,\n      notifyOnNetworkStatusChange = _d === void 0 ? false : _d,\n      _e = options.context,\n      context = _e === void 0 ? {} : _e;\n    var mightUseNetwork = fetchPolicy === \"cache-first\" || fetchPolicy === \"cache-and-network\" || fetchPolicy === \"network-only\" || fetchPolicy === \"no-cache\";\n    if (mightUseNetwork && notifyOnNetworkStatusChange && typeof oldNetworkStatus === \"number\" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight(networkStatus)) {\n      if (fetchPolicy !== \"cache-first\") {\n        fetchPolicy = \"cache-and-network\";\n      }\n      returnPartialData = true;\n    }\n    var normalized = Object.assign({}, options, {\n      query: query,\n      variables: variables,\n      fetchPolicy: fetchPolicy,\n      errorPolicy: errorPolicy,\n      returnPartialData: returnPartialData,\n      notifyOnNetworkStatusChange: notifyOnNetworkStatusChange,\n      context: context\n    });\n    var fromVariables = function fromVariables(variables) {\n      normalized.variables = variables;\n      return _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);\n    };\n    this.fetchCancelFns.set(queryId, function (reason) {\n      Promise.resolve().then(function () {\n        return concast.cancel(reason);\n      });\n    });\n    var concast = new Concast(this.transform(normalized.query).hasClientExports ? this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables) : fromVariables(normalized.variables));\n    concast.cleanup(function () {\n      _this.fetchCancelFns.delete(queryId);\n      var nextFetchPolicy = options.nextFetchPolicy;\n      if (nextFetchPolicy) {\n        options.nextFetchPolicy = void 0;\n        options.fetchPolicy = typeof nextFetchPolicy === \"function\" ? nextFetchPolicy.call(options, options.fetchPolicy || \"cache-first\") : nextFetchPolicy;\n      }\n    });\n    return concast;\n  };\n  QueryManager.prototype.fetchQueryByPolicy = function (queryInfo, options, networkStatus) {\n    var _this = this;\n    var query = options.query,\n      variables = options.variables,\n      fetchPolicy = options.fetchPolicy,\n      errorPolicy = options.errorPolicy,\n      returnPartialData = options.returnPartialData,\n      context = options.context;\n    queryInfo.init({\n      document: query,\n      variables: variables,\n      lastRequestId: this.generateRequestId(),\n      networkStatus: networkStatus\n    });\n    var readCache = function readCache() {\n      return queryInfo.getDiff(variables);\n    };\n    var resultsFromCache = function resultsFromCache(diff, networkStatus) {\n      if (networkStatus === void 0) {\n        networkStatus = queryInfo.networkStatus || NetworkStatus.loading;\n      }\n      var data = diff.result;\n      if (process.env.NODE_ENV !== 'production' && isNonEmptyArray(diff.missing) && !equal(data, {}) && !returnPartialData) {\n        process.env.NODE_ENV === \"production\" || invariant.warn(\"Missing cache result fields: \" + diff.missing.map(function (m) {\n          return m.path.join('.');\n        }).join(', '), diff.missing);\n      }\n      var fromData = function fromData(data) {\n        return Observable.of(__assign({\n          data: data,\n          loading: isNetworkRequestInFlight(networkStatus),\n          networkStatus: networkStatus\n        }, diff.complete ? null : {\n          partial: true\n        }));\n      };\n      if (_this.transform(query).hasForcedResolvers) {\n        return _this.localState.runResolvers({\n          document: query,\n          remoteResult: {\n            data: data\n          },\n          context: context,\n          variables: variables,\n          onlyRunForcedResolvers: true\n        }).then(function (resolved) {\n          return fromData(resolved.data);\n        });\n      }\n      return fromData(data);\n    };\n    var resultsFromLink = function resultsFromLink(allowCacheWrite) {\n      return _this.getResultsFromLink(queryInfo, allowCacheWrite, {\n        variables: variables,\n        context: context,\n        fetchPolicy: fetchPolicy,\n        errorPolicy: errorPolicy\n      });\n    };\n    switch (fetchPolicy) {\n      default:\n      case \"cache-first\":\n        {\n          var diff = readCache();\n          if (diff.complete) {\n            return [resultsFromCache(diff, queryInfo.markReady())];\n          }\n          if (returnPartialData) {\n            return [resultsFromCache(diff), resultsFromLink(true)];\n          }\n          return [resultsFromLink(true)];\n        }\n      case \"cache-and-network\":\n        {\n          var diff = readCache();\n          if (diff.complete || returnPartialData) {\n            return [resultsFromCache(diff), resultsFromLink(true)];\n          }\n          return [resultsFromLink(true)];\n        }\n      case \"cache-only\":\n        return [resultsFromCache(readCache(), queryInfo.markReady())];\n      case \"network-only\":\n        return [resultsFromLink(true)];\n      case \"no-cache\":\n        return [resultsFromLink(false)];\n      case \"standby\":\n        return [];\n    }\n  };\n  QueryManager.prototype.getQuery = function (queryId) {\n    if (queryId && !this.queries.has(queryId)) {\n      this.queries.set(queryId, new QueryInfo(this.cache));\n    }\n    return this.queries.get(queryId);\n  };\n  QueryManager.prototype.prepareContext = function (context) {\n    if (context === void 0) {\n      context = {};\n    }\n    var newContext = this.localState.prepareContext(context);\n    return __assign(__assign({}, newContext), {\n      clientAwareness: this.clientAwareness\n    });\n  };\n  return QueryManager;\n}();\nexport { QueryManager };","map":{"version":3,"sources":["../../src/core/QueryManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { DocumentNode } from 'graphql';\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { equal } from '@wry/equality';\n\nimport { ApolloLink, execute, FetchResult } from '../link/core';\nimport { Cache, ApolloCache } from '../cache';\n\nimport {\n  getDefaultValues,\n  getOperationDefinition,\n  getOperationName,\n  hasClientExports,\n  graphQLResultHasError,\n  removeConnectionDirectiveFromDocument,\n  canUseWeakMap,\n  ObservableSubscription,\n  Observable,\n  asyncMap,\n  isNonEmptyArray,\n  Concast,\n  ConcastSourcesIterable,\n} from '../utilities';\nimport { ApolloError, isApolloError } from '../errors';\nimport {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  WatchQueryFetchPolicy,\n  ErrorPolicy,\n} from './watchQueryOptions';\nimport { ObservableQuery } from './ObservableQuery';\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus';\nimport {\n  ApolloQueryResult,\n  OperationVariables,\n} from './types';\nimport { LocalState } from './LocalState';\n\nimport { QueryInfo, QueryStoreValue, shouldWriteResult } from './QueryInfo';\n\nconst { hasOwnProperty } = Object.prototype;\n\ninterface MutationStoreValue {\n  mutation: DocumentNode;\n  variables: Record<string, any>;\n  loading: boolean;\n  error: Error | null;\n}\n\nexport class QueryManager<TStore> {\n  public cache: ApolloCache<TStore>;\n  public link: ApolloLink;\n  public readonly assumeImmutableResults: boolean;\n  public readonly ssrMode: boolean;\n\n  private queryDeduplication: boolean;\n  private clientAwareness: Record<string, string> = {};\n  private localState: LocalState<TStore>;\n\n  private onBroadcast?: () => void;\n  public mutationStore?: {\n    [mutationId: string]: MutationStoreValue;\n  };\n\n  // All the queries that the QueryManager is currently managing (not\n  // including mutations and subscriptions).\n  private queries = new Map<string, QueryInfo>();\n\n  // Maps from queryId strings to Promise rejection functions for\n  // currently active queries and fetches.\n  private fetchCancelFns = new Map<string, (error: any) => any>();\n\n  constructor({\n    cache,\n    link,\n    queryDeduplication = false,\n    onBroadcast,\n    ssrMode = false,\n    clientAwareness = {},\n    localState,\n    assumeImmutableResults,\n  }: {\n    cache: ApolloCache<TStore>;\n    link: ApolloLink;\n    queryDeduplication?: boolean;\n    onBroadcast?: () => void;\n    ssrMode?: boolean;\n    clientAwareness?: Record<string, string>;\n    localState?: LocalState<TStore>;\n    assumeImmutableResults?: boolean;\n  }) {\n    this.cache = cache;\n    this.link = link;\n    this.queryDeduplication = queryDeduplication;\n    this.clientAwareness = clientAwareness;\n    this.localState = localState || new LocalState({ cache });\n    this.ssrMode = ssrMode;\n    this.assumeImmutableResults = !!assumeImmutableResults;\n    if ((this.onBroadcast = onBroadcast)) {\n      this.mutationStore = Object.create(null);\n    }\n  }\n\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n  public stop() {\n    this.queries.forEach((_info, queryId) => {\n      this.stopQueryNoBroadcast(queryId);\n    });\n\n    this.cancelPendingFetches(\n      new InvariantError('QueryManager stopped while query was in flight'),\n    );\n  }\n\n  private cancelPendingFetches(error: Error) {\n    this.fetchCancelFns.forEach(cancel => cancel(error));\n    this.fetchCancelFns.clear();\n  }\n\n  public async mutate<T>({\n    mutation,\n    variables,\n    optimisticResponse,\n    updateQueries,\n    refetchQueries = [],\n    awaitRefetchQueries = false,\n    update: updateWithProxyFn,\n    errorPolicy = 'none',\n    fetchPolicy,\n    context = {},\n  }: MutationOptions): Promise<FetchResult<T>> {\n    invariant(\n      mutation,\n      'mutation option is required. You must specify your GraphQL document in the mutation option.',\n    );\n\n    invariant(\n      !fetchPolicy || fetchPolicy === 'no-cache',\n      \"Mutations only support a 'no-cache' fetchPolicy. If you don't want to disable the cache, remove your fetchPolicy setting to proceed with the default mutation behavior.\"\n    );\n\n    const mutationId = this.generateMutationId();\n    mutation = this.transform(mutation).document;\n\n    variables = this.getVariables(mutation, variables);\n\n    if (this.transform(mutation).hasClientExports) {\n      variables = await this.localState.addExportedVariables(mutation, variables, context);\n    }\n\n    const mutationStoreValue =\n      this.mutationStore &&\n      (this.mutationStore[mutationId] = {\n        mutation,\n        variables,\n        loading: true,\n        error: null,\n      } as MutationStoreValue);\n\n    if (optimisticResponse) {\n      this.markMutationOptimistic<T>(optimisticResponse, {\n        mutationId,\n        document: mutation,\n        variables,\n        errorPolicy,\n        updateQueries,\n        update: updateWithProxyFn,\n      });\n    }\n\n    this.broadcastQueries();\n\n    const self = this;\n\n    return new Promise((resolve, reject) => {\n      let storeResult: FetchResult<T> | null;\n      let error: ApolloError;\n\n      self.getObservableFromLink(\n        mutation,\n        {\n          ...context,\n          optimisticResponse,\n        },\n        variables,\n        false,\n      ).subscribe({\n        next(result: FetchResult<T>) {\n          if (graphQLResultHasError(result) && errorPolicy === 'none') {\n            error = new ApolloError({\n              graphQLErrors: result.errors,\n            });\n            return;\n          }\n\n          if (mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = null;\n          }\n\n          if (fetchPolicy !== 'no-cache') {\n            try {\n              self.markMutationResult<T>({\n                mutationId,\n                result,\n                document: mutation,\n                variables,\n                errorPolicy,\n                updateQueries,\n                update: updateWithProxyFn,\n              });\n            } catch (e) {\n              error = new ApolloError({\n                networkError: e,\n              });\n              return;\n            }\n          }\n\n          storeResult = result;\n        },\n\n        error(err: Error) {\n          if (mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = err;\n          }\n          if (optimisticResponse) {\n            self.cache.removeOptimistic(mutationId);\n          }\n          self.broadcastQueries();\n          reject(\n            new ApolloError({\n              networkError: err,\n            }),\n          );\n        },\n\n        complete() {\n          if (error && mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = error;\n          }\n\n          if (optimisticResponse) {\n            self.cache.removeOptimistic(mutationId);\n          }\n\n          self.broadcastQueries();\n\n          if (error) {\n            reject(error);\n            return;\n          }\n\n          // allow for conditional refetches\n          // XXX do we want to make this the only API one day?\n          if (typeof refetchQueries === 'function') {\n            refetchQueries = refetchQueries(storeResult!);\n          }\n\n          const refetchQueryPromises: Promise<\n            ApolloQueryResult<any>[] | ApolloQueryResult<{}>\n          >[] = [];\n\n          if (isNonEmptyArray(refetchQueries)) {\n            refetchQueries.forEach(refetchQuery => {\n              if (typeof refetchQuery === 'string') {\n                self.queries.forEach(({ observableQuery }) => {\n                  if (observableQuery &&\n                      observableQuery.hasObservers() &&\n                      observableQuery.queryName === refetchQuery) {\n                    refetchQueryPromises.push(observableQuery.refetch());\n                  }\n                });\n              } else {\n                const queryOptions: QueryOptions = {\n                  query: refetchQuery.query,\n                  variables: refetchQuery.variables,\n                  fetchPolicy: 'network-only',\n                };\n\n                if (refetchQuery.context) {\n                  queryOptions.context = refetchQuery.context;\n                }\n\n                refetchQueryPromises.push(self.query(queryOptions));\n              }\n            });\n          }\n\n          Promise.all(\n            awaitRefetchQueries ? refetchQueryPromises : [],\n          ).then(() => {\n            if (\n              errorPolicy === 'ignore' &&\n              storeResult &&\n              graphQLResultHasError(storeResult)\n            ) {\n              delete storeResult.errors;\n            }\n\n            resolve(storeResult!);\n          }, reject);\n        },\n      });\n    });\n  }\n\n  public markMutationResult<TData>(\n    mutation: {\n      mutationId: string;\n      result: FetchResult<TData>;\n      document: DocumentNode;\n      variables?: OperationVariables;\n      errorPolicy: ErrorPolicy;\n      updateQueries: MutationOptions<TData>[\"updateQueries\"],\n      update?: (\n        cache: ApolloCache<TStore>,\n        result: FetchResult<TData>,\n      ) => void;\n    },\n    cache = this.cache,\n  ) {\n    if (shouldWriteResult(mutation.result, mutation.errorPolicy)) {\n      const cacheWrites: Cache.WriteOptions[] = [{\n        result: mutation.result.data,\n        dataId: 'ROOT_MUTATION',\n        query: mutation.document,\n        variables: mutation.variables,\n      }];\n\n      const { updateQueries } = mutation;\n      if (updateQueries) {\n        this.queries.forEach(({ observableQuery }, queryId) => {\n          const queryName = observableQuery && observableQuery.queryName;\n          if (!queryName || !hasOwnProperty.call(updateQueries, queryName)) {\n            return;\n          }\n          const updater = updateQueries[queryName];\n          const { document, variables } = this.queries.get(queryId)!;\n\n          // Read the current query result from the store.\n          const { result: currentQueryResult, complete } = cache.diff<TData>({\n            query: document!,\n            variables,\n            returnPartialData: true,\n            optimistic: false,\n          });\n\n          if (complete && currentQueryResult) {\n            // Run our reducer using the current query result and the mutation result.\n            const nextQueryResult = updater(currentQueryResult, {\n              mutationResult: mutation.result,\n              queryName: document && getOperationName(document) || void 0,\n              queryVariables: variables!,\n            });\n\n            // Write the modified result back into the store if we got a new result.\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: 'ROOT_QUERY',\n                query: document!,\n                variables,\n              });\n            }\n          }\n        });\n      }\n\n      cache.performTransaction(c => {\n        cacheWrites.forEach(write => c.write(write));\n\n        // If the mutation has some writes associated with it then we need to\n        // apply those writes to the store by running this reducer again with a\n        // write action.\n        const { update } = mutation;\n        if (update) {\n          update(c, mutation.result);\n        }\n      }, /* non-optimistic transaction: */ null);\n    }\n  }\n\n  public markMutationOptimistic<TData>(\n    optimisticResponse: any,\n    mutation: {\n      mutationId: string;\n      document: DocumentNode;\n      variables?: OperationVariables;\n      errorPolicy: ErrorPolicy;\n      updateQueries: MutationOptions<TData>[\"updateQueries\"],\n      update?: (\n        cache: ApolloCache<TStore>,\n        result: FetchResult<TData>,\n      ) => void;\n    },\n  ) {\n    const data = typeof optimisticResponse === \"function\"\n      ? optimisticResponse(mutation.variables)\n      : optimisticResponse;\n\n    return this.cache.recordOptimisticTransaction(cache => {\n      try {\n        this.markMutationResult<TData>({\n          ...mutation,\n          result: { data },\n        }, cache);\n      } catch (error) {\n        invariant.error(error);\n      }\n    }, mutation.mutationId);\n  }\n\n  public fetchQuery<TData, TVars>(\n    queryId: string,\n    options: WatchQueryOptions<TVars, TData>,\n    networkStatus?: NetworkStatus,\n  ): Promise<ApolloQueryResult<TData>> {\n    return this.fetchQueryObservable<TData, TVars>(\n      queryId,\n      options,\n      networkStatus,\n    ).promise;\n  }\n\n  public getQueryStore() {\n    const store: Record<string, QueryStoreValue> = Object.create(null);\n    this.queries.forEach((info, queryId) => {\n      store[queryId] = {\n        variables: info.variables,\n        networkStatus: info.networkStatus,\n        networkError: info.networkError,\n        graphQLErrors: info.graphQLErrors,\n      };\n    });\n    return store;\n  }\n\n  public resetErrors(queryId: string) {\n    const queryInfo = this.queries.get(queryId);\n    if (queryInfo) {\n      queryInfo.networkError = undefined;\n      queryInfo.graphQLErrors = [];\n    }\n  }\n\n  private transformCache = new (canUseWeakMap ? WeakMap : Map)<\n    DocumentNode,\n    Readonly<{\n      document: Readonly<DocumentNode>;\n      hasClientExports: boolean;\n      hasForcedResolvers: boolean;\n      clientQuery: Readonly<DocumentNode> | null;\n      serverQuery: Readonly<DocumentNode> | null;\n      defaultVars: Readonly<OperationVariables>;\n    }>\n  >();\n\n  public transform(document: DocumentNode) {\n    const { transformCache } = this;\n\n    if (!transformCache.has(document)) {\n      const transformed = this.cache.transformDocument(document);\n      const forLink = removeConnectionDirectiveFromDocument(\n        this.cache.transformForLink(transformed));\n\n      const clientQuery = this.localState.clientQuery(transformed);\n      const serverQuery = forLink && this.localState.serverQuery(forLink);\n\n      const cacheEntry = {\n        document: transformed,\n        // TODO These two calls (hasClientExports and shouldForceResolvers)\n        // could probably be merged into a single traversal.\n        hasClientExports: hasClientExports(transformed),\n        hasForcedResolvers: this.localState.shouldForceResolvers(transformed),\n        clientQuery,\n        serverQuery,\n        defaultVars: getDefaultValues(\n          getOperationDefinition(transformed)\n        ) as OperationVariables,\n      };\n\n      const add = (doc: DocumentNode | null) => {\n        if (doc && !transformCache.has(doc)) {\n          transformCache.set(doc, cacheEntry);\n        }\n      }\n      // Add cacheEntry to the transformCache using several different keys,\n      // since any one of these documents could end up getting passed to the\n      // transform method again in the future.\n      add(document);\n      add(transformed);\n      add(clientQuery);\n      add(serverQuery);\n    }\n\n    return transformCache.get(document)!;\n  }\n\n  private getVariables(\n    document: DocumentNode,\n    variables?: OperationVariables,\n  ): OperationVariables {\n    return {\n      ...this.transform(document).defaultVars,\n      ...variables,\n    };\n  }\n\n  public watchQuery<T, TVariables = OperationVariables>(\n    options: WatchQueryOptions<TVariables, T>,\n  ): ObservableQuery<T, TVariables> {\n    // assign variable default values if supplied\n    options = {\n      ...options,\n      variables: this.getVariables(\n        options.query,\n        options.variables,\n      ) as TVariables,\n    };\n\n    if (typeof options.notifyOnNetworkStatusChange === 'undefined') {\n      options.notifyOnNetworkStatusChange = false;\n    }\n\n    const queryInfo = new QueryInfo(this.cache);\n    const observable = new ObservableQuery<T, TVariables>({\n      queryManager: this,\n      queryInfo,\n      options,\n    });\n\n    this.queries.set(observable.queryId, queryInfo);\n\n    queryInfo.init({\n      document: options.query,\n      observableQuery: observable,\n      variables: options.variables,\n    });\n\n    return observable;\n  }\n\n  public query<TData, TVars = OperationVariables>(\n    options: QueryOptions<TVars, TData>,\n  ): Promise<ApolloQueryResult<TData>> {\n    invariant(\n      options.query,\n      'query option is required. You must specify your GraphQL document ' +\n        'in the query option.',\n    );\n\n    invariant(\n      options.query.kind === 'Document',\n      'You must wrap the query string in a \"gql\" tag.',\n    );\n\n    invariant(\n      !(options as any).returnPartialData,\n      'returnPartialData option only supported on watchQuery.',\n    );\n\n    invariant(\n      !(options as any).pollInterval,\n      'pollInterval option only supported on watchQuery.',\n    );\n\n    const queryId = this.generateQueryId();\n    return this.fetchQuery<TData, TVars>(\n      queryId,\n      options,\n    ).finally(() => this.stopQuery(queryId));\n  }\n\n  private queryIdCounter = 1;\n  public generateQueryId() {\n    return String(this.queryIdCounter++);\n  }\n\n  private requestIdCounter = 1;\n  public generateRequestId() {\n    return this.requestIdCounter++;\n  }\n\n  private mutationIdCounter = 1;\n  public generateMutationId() {\n    return String(this.mutationIdCounter++);\n  }\n\n  public stopQueryInStore(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryInStoreNoBroadcast(queryId: string) {\n    const queryInfo = this.queries.get(queryId);\n    if (queryInfo) queryInfo.stop();\n  }\n\n  public clearStore(): Promise<void> {\n    // Before we have sent the reset action to the store, we can no longer\n    // rely on the results returned by in-flight requests since these may\n    // depend on values that previously existed in the data portion of the\n    // store. So, we cancel the promises and observers that we have issued\n    // so far and not yet resolved (in the case of queries).\n    this.cancelPendingFetches(new InvariantError(\n      'Store reset while query was in flight (not completed in link chain)',\n    ));\n\n    this.queries.forEach(queryInfo => {\n      if (queryInfo.observableQuery) {\n        // Set loading to true so listeners don't trigger unless they want\n        // results with partial data.\n        queryInfo.networkStatus = NetworkStatus.loading;\n      } else {\n        queryInfo.stop();\n      }\n    });\n\n    if (this.mutationStore) {\n      this.mutationStore = Object.create(null);\n    }\n\n    // begin removing data from the store\n    return this.cache.reset();\n  }\n\n  public resetStore(): Promise<ApolloQueryResult<any>[]> {\n    // Similarly, we have to have to refetch each of the queries currently being\n    // observed. We refetch instead of error'ing on these since the assumption is that\n    // resetting the store doesn't eliminate the need for the queries currently being\n    // watched. If there is an existing query in flight when the store is reset,\n    // the promise for it will be rejected and its results will not be written to the\n    // store.\n    return this.clearStore().then(() => {\n      return this.reFetchObservableQueries();\n    });\n  }\n\n  public reFetchObservableQueries(\n    includeStandby: boolean = false,\n  ): Promise<ApolloQueryResult<any>[]> {\n    const observableQueryPromises: Promise<ApolloQueryResult<any>>[] = [];\n\n    this.queries.forEach(({ observableQuery }, queryId) => {\n      if (observableQuery && observableQuery.hasObservers()) {\n        const fetchPolicy = observableQuery.options.fetchPolicy;\n\n        observableQuery.resetLastResults();\n        if (\n          fetchPolicy !== 'cache-only' &&\n          (includeStandby || fetchPolicy !== 'standby')\n        ) {\n          observableQueryPromises.push(observableQuery.refetch());\n        }\n\n        this.getQuery(queryId).setDiff(null);\n      }\n    });\n\n    this.broadcastQueries();\n\n    return Promise.all(observableQueryPromises);\n  }\n\n  public setObservableQuery(observableQuery: ObservableQuery<any, any>) {\n    this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);\n  }\n\n  public startGraphQLSubscription<T = any>({\n    query,\n    fetchPolicy,\n    errorPolicy,\n    variables,\n    context = {},\n  }: SubscriptionOptions): Observable<FetchResult<T>> {\n    query = this.transform(query).document;\n    variables = this.getVariables(query, variables);\n\n    const makeObservable = (variables: OperationVariables) =>\n      this.getObservableFromLink<T>(\n        query,\n        context,\n        variables,\n        false,\n      ).map(result => {\n        if (fetchPolicy !== 'no-cache') {\n          // the subscription interface should handle not sending us results we no longer subscribe to.\n          // XXX I don't think we ever send in an object with errors, but we might in the future...\n          if (shouldWriteResult(result, errorPolicy)) {\n            this.cache.write({\n              query,\n              result: result.data,\n              dataId: 'ROOT_SUBSCRIPTION',\n              variables: variables,\n            });\n          }\n\n          this.broadcastQueries();\n        }\n\n        if (graphQLResultHasError(result)) {\n          throw new ApolloError({\n            graphQLErrors: result.errors,\n          });\n        }\n\n        return result;\n      });\n\n    if (this.transform(query).hasClientExports) {\n      const observablePromise = this.localState.addExportedVariables(\n        query,\n        variables,\n        context,\n      ).then(makeObservable);\n\n      return new Observable<FetchResult<T>>(observer => {\n        let sub: ObservableSubscription | null = null;\n        observablePromise.then(\n          observable => sub = observable.subscribe(observer),\n          observer.error,\n        );\n        return () => sub && sub.unsubscribe();\n      });\n    }\n\n    return makeObservable(variables);\n  }\n\n  public stopQuery(queryId: string) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryNoBroadcast(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  }\n\n  public removeQuery(queryId: string) {\n    // teardown all links\n    // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n    // that each add their reject functions to fetchCancelFns.\n    // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n    // The same queryId could have two rejection fns for two promises\n    this.fetchCancelFns.delete(queryId);\n    this.getQuery(queryId).stop();\n    this.queries.delete(queryId);\n  }\n\n  public broadcastQueries() {\n    if (this.onBroadcast) this.onBroadcast();\n    this.queries.forEach(info => info.notify());\n  }\n\n  public getLocalState(): LocalState<TStore> {\n    return this.localState;\n  }\n\n  private inFlightLinkObservables = new Map<\n    DocumentNode,\n    Map<string, Observable<FetchResult>>\n  >();\n\n  private getObservableFromLink<T = any>(\n    query: DocumentNode,\n    context: any,\n    variables?: OperationVariables,\n    deduplication: boolean =\n      // Prefer context.queryDeduplication if specified.\n      context?.queryDeduplication ??\n      this.queryDeduplication,\n  ): Observable<FetchResult<T>> {\n    let observable: Observable<FetchResult<T>>;\n\n    const { serverQuery } = this.transform(query);\n    if (serverQuery) {\n      const { inFlightLinkObservables, link } = this;\n\n      const operation = {\n        query: serverQuery,\n        variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext({\n          ...context,\n          forceFetch: !deduplication\n        }),\n      };\n\n      context = operation.context;\n\n      if (deduplication) {\n        const byVariables = inFlightLinkObservables.get(serverQuery) || new Map();\n        inFlightLinkObservables.set(serverQuery, byVariables);\n\n        const varJson = JSON.stringify(variables);\n        observable = byVariables.get(varJson);\n\n        if (!observable) {\n          const concast = new Concast([\n            execute(link, operation) as Observable<FetchResult<T>>\n          ]);\n\n          byVariables.set(varJson, observable = concast);\n\n          concast.cleanup(() => {\n            if (byVariables.delete(varJson) &&\n                byVariables.size < 1) {\n              inFlightLinkObservables.delete(serverQuery);\n            }\n          });\n        }\n\n      } else {\n        observable = new Concast([\n          execute(link, operation) as Observable<FetchResult<T>>\n        ]);\n      }\n    } else {\n      observable = new Concast([\n        Observable.of({ data: {} } as FetchResult<T>)\n      ]);\n      context = this.prepareContext(context);\n    }\n\n    const { clientQuery } = this.transform(query);\n    if (clientQuery) {\n      observable = asyncMap(observable, result => {\n        return this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context,\n          variables,\n        });\n      });\n    }\n\n    return observable;\n  }\n\n  private getResultsFromLink<TData, TVars>(\n    queryInfo: QueryInfo,\n    allowCacheWrite: boolean,\n    options: Pick<WatchQueryOptions<TVars, TData>,\n      | \"variables\"\n      | \"context\"\n      | \"fetchPolicy\"\n      | \"errorPolicy\">,\n  ): Observable<ApolloQueryResult<TData>> {\n    const { lastRequestId } = queryInfo;\n\n    return asyncMap(\n      this.getObservableFromLink(\n        queryInfo.document!,\n        options.context,\n        options.variables,\n      ),\n\n      result => {\n        const hasErrors = isNonEmptyArray(result.errors);\n\n        if (lastRequestId >= queryInfo.lastRequestId) {\n          if (hasErrors && options.errorPolicy === \"none\") {\n            // Throwing here effectively calls observer.error.\n            throw queryInfo.markError(new ApolloError({\n              graphQLErrors: result.errors,\n            }));\n          }\n          queryInfo.markResult(result, options, allowCacheWrite);\n          queryInfo.markReady();\n        }\n\n        const aqr: ApolloQueryResult<TData> = {\n          data: result.data,\n          loading: false,\n          networkStatus: queryInfo.networkStatus || NetworkStatus.ready,\n        };\n\n        if (hasErrors && options.errorPolicy !== \"ignore\") {\n          aqr.errors = result.errors;\n        }\n\n        return aqr;\n      },\n\n      networkError => {\n        const error = isApolloError(networkError)\n          ? networkError\n          : new ApolloError({ networkError });\n\n        if (lastRequestId >= queryInfo.lastRequestId) {\n          queryInfo.markError(error);\n        }\n\n        throw error;\n      },\n    );\n  }\n\n  public fetchQueryObservable<TData, TVars>(\n    queryId: string,\n    options: WatchQueryOptions<TVars, TData>,\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus = NetworkStatus.loading,\n  ): Concast<ApolloQueryResult<TData>> {\n    const query = this.transform(options.query).document;\n    const variables = this.getVariables(query, options.variables) as TVars;\n    const queryInfo = this.getQuery(queryId);\n    const oldNetworkStatus = queryInfo.networkStatus;\n\n    let {\n      fetchPolicy = \"cache-first\" as WatchQueryFetchPolicy,\n      errorPolicy = \"none\" as ErrorPolicy,\n      returnPartialData = false,\n      notifyOnNetworkStatusChange = false,\n      context = {},\n    } = options;\n\n    const mightUseNetwork =\n      fetchPolicy === \"cache-first\" ||\n      fetchPolicy === \"cache-and-network\" ||\n      fetchPolicy === \"network-only\" ||\n      fetchPolicy === \"no-cache\";\n\n    if (mightUseNetwork &&\n        notifyOnNetworkStatusChange &&\n        typeof oldNetworkStatus === \"number\" &&\n        oldNetworkStatus !== networkStatus &&\n        isNetworkRequestInFlight(networkStatus)) {\n      // In order to force delivery of an incomplete cache result with\n      // loading:true, we tweak the fetchPolicy to include the cache, and\n      // pretend that returnPartialData was enabled.\n      if (fetchPolicy !== \"cache-first\") {\n        fetchPolicy = \"cache-and-network\";\n      }\n      returnPartialData = true;\n    }\n\n    const normalized = Object.assign({}, options, {\n      query,\n      variables,\n      fetchPolicy,\n      errorPolicy,\n      returnPartialData,\n      notifyOnNetworkStatusChange,\n      context,\n    });\n\n    const fromVariables = (variables: TVars) => {\n      // Since normalized is always a fresh copy of options, it's safe to\n      // modify its properties here, rather than creating yet another new\n      // WatchQueryOptions object.\n      normalized.variables = variables;\n      return this.fetchQueryByPolicy<TData, TVars>(\n        queryInfo,\n        normalized,\n        networkStatus,\n      );\n    };\n\n    // This cancel function needs to be set before the concast is created,\n    // in case concast creation synchronously cancels the request.\n    this.fetchCancelFns.set(queryId, reason => {\n      // Delaying the cancellation using a Promise ensures that the\n      // concast variable has been initialized.\n      Promise.resolve().then(() => concast.cancel(reason));\n    });\n\n    // A Concast<T> can be created either from an Iterable<Observable<T>>\n    // or from a PromiseLike<Iterable<Observable<T>>>, where T in this\n    // case is ApolloQueryResult<TData>.\n    const concast = new Concast(\n      // If the query has @export(as: ...) directives, then we need to\n      // process those directives asynchronously. When there are no\n      // @export directives (the common case), we deliberately avoid\n      // wrapping the result of this.fetchQueryByPolicy in a Promise,\n      // since the timing of result delivery is (unfortunately) important\n      // for backwards compatibility. TODO This code could be simpler if\n      // we deprecated and removed LocalState.\n      this.transform(normalized.query).hasClientExports\n        ? this.localState.addExportedVariables(\n          normalized.query,\n          normalized.variables,\n          normalized.context,\n        ).then(fromVariables)\n        : fromVariables(normalized.variables!)\n    );\n\n    concast.cleanup(() => {\n      this.fetchCancelFns.delete(queryId);\n\n      const { nextFetchPolicy } = options;\n      if (nextFetchPolicy) {\n        // The options.nextFetchPolicy transition should happen only once,\n        // but it should be possible for a nextFetchPolicy function to set\n        // this.nextFetchPolicy to perform an additional transition.\n        options.nextFetchPolicy = void 0;\n\n        // When someone chooses cache-and-network or network-only as their\n        // initial FetchPolicy, they often do not want future cache updates to\n        // trigger unconditional network requests, which is what repeatedly\n        // applying the cache-and-network or network-only policies would seem\n        // to imply. Instead, when the cache reports an update after the\n        // initial network request, it may be desirable for subsequent network\n        // requests to be triggered only if the cache result is incomplete.\n        // The options.nextFetchPolicy option provides an easy way to update\n        // options.fetchPolicy after the intial network request, without\n        // having to call observableQuery.setOptions.\n        options.fetchPolicy = typeof nextFetchPolicy === \"function\"\n          ? nextFetchPolicy.call(options, options.fetchPolicy || \"cache-first\")\n          : nextFetchPolicy;\n      }\n    });\n\n    return concast;\n  }\n\n  private fetchQueryByPolicy<TData, TVars>(\n    queryInfo: QueryInfo,\n    options: WatchQueryOptions<TVars, TData>,\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus: NetworkStatus,\n  ): ConcastSourcesIterable<ApolloQueryResult<TData>> {\n    const {\n      query,\n      variables,\n      fetchPolicy,\n      errorPolicy,\n      returnPartialData,\n      context,\n    } = options;\n\n    queryInfo.init({\n      document: query,\n      variables,\n      lastRequestId: this.generateRequestId(),\n      networkStatus,\n    });\n\n    const readCache = () => queryInfo.getDiff(variables);\n\n    const resultsFromCache = (\n      diff: Cache.DiffResult<TData>,\n      networkStatus = queryInfo.networkStatus || NetworkStatus.loading,\n    ) => {\n      const data = diff.result as TData;\n\n      if (process.env.NODE_ENV !== 'production' &&\n          isNonEmptyArray(diff.missing) &&\n          !equal(data, {}) &&\n          !returnPartialData) {\n        invariant.warn(`Missing cache result fields: ${\n          diff.missing.map(m => m.path.join('.')).join(', ')\n        }`, diff.missing);\n      }\n\n      const fromData = (data: TData) => Observable.of({\n        data,\n        loading: isNetworkRequestInFlight(networkStatus),\n        networkStatus,\n        ...(diff.complete ? null : { partial: true }),\n      } as ApolloQueryResult<TData>);\n\n      if (this.transform(query).hasForcedResolvers) {\n        return this.localState.runResolvers({\n          document: query,\n          remoteResult: { data },\n          context,\n          variables,\n          onlyRunForcedResolvers: true,\n        }).then(resolved => fromData(resolved.data!));\n      }\n\n      return fromData(data);\n    };\n\n    const resultsFromLink = (allowCacheWrite: boolean) =>\n      this.getResultsFromLink<TData, TVars>(queryInfo, allowCacheWrite, {\n        variables,\n        context,\n        fetchPolicy,\n        errorPolicy,\n      });\n\n    switch (fetchPolicy) {\n    default: case \"cache-first\": {\n      const diff = readCache();\n\n      if (diff.complete) {\n        return [\n          resultsFromCache(diff, queryInfo.markReady()),\n        ];\n      }\n\n      if (returnPartialData) {\n        return [\n          resultsFromCache(diff),\n          resultsFromLink(true),\n        ];\n      }\n\n      return [\n        resultsFromLink(true),\n      ];\n    }\n\n    case \"cache-and-network\": {\n      const diff = readCache();\n\n      if (diff.complete || returnPartialData) {\n        return [\n          resultsFromCache(diff),\n          resultsFromLink(true),\n        ];\n      }\n\n      return [\n        resultsFromLink(true),\n      ];\n    }\n\n    case \"cache-only\":\n      return [\n        resultsFromCache(readCache(), queryInfo.markReady()),\n      ];\n\n    case \"network-only\":\n      return [resultsFromLink(true)];\n\n    case \"no-cache\":\n      return [resultsFromLink(false)];\n\n    case \"standby\":\n      return [];\n    }\n  }\n\n  private getQuery(queryId: string): QueryInfo {\n    if (queryId && !this.queries.has(queryId)) {\n      this.queries.set(queryId, new QueryInfo(this.cache));\n    }\n    return this.queries.get(queryId)!;\n  }\n\n  private prepareContext(context = {}) {\n    const newContext = this.localState.prepareContext(context);\n    return {\n      ...newContext,\n      clientAwareness: this.clientAwareness,\n    };\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}