{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { useContext, useEffect, useReducer, useRef } from 'react';\nimport { QueryData } from \"../../data/index.js\";\nimport { useDeepMemo } from \"./useDeepMemo.js\";\nimport { getApolloContext } from \"../../context/index.js\";\nexport function useBaseQuery(query, options, lazy) {\n  if (lazy === void 0) {\n    lazy = false;\n  }\n  var context = useContext(getApolloContext());\n  var _a = useReducer(function (x) {\n      return x + 1;\n    }, 0),\n    tick = _a[0],\n    forceUpdate = _a[1];\n  var updatedOptions = options ? __assign(__assign({}, options), {\n    query: query\n  }) : {\n    query: query\n  };\n  var queryDataRef = useRef();\n  var queryData = queryDataRef.current || (queryDataRef.current = new QueryData({\n    options: updatedOptions,\n    context: context,\n    onNewData: function onNewData() {\n      if (!queryData.ssrInitiated()) {\n        Promise.resolve().then(function () {\n          return queryDataRef.current && forceUpdate();\n        });\n      } else {\n        forceUpdate();\n      }\n    }\n  }));\n  queryData.setOptions(updatedOptions);\n  queryData.context = context;\n  var memo = {\n    options: __assign(__assign({}, updatedOptions), {\n      onError: undefined,\n      onCompleted: undefined\n    }),\n    context: context,\n    tick: tick\n  };\n  var result = useDeepMemo(function () {\n    return lazy ? queryData.executeLazy() : queryData.execute();\n  }, memo);\n  var queryResult = lazy ? result[1] : result;\n  useEffect(function () {\n    return function () {\n      return queryData.cleanup();\n    };\n  }, []);\n  useEffect(function () {\n    return queryData.afterExecute({\n      lazy: lazy\n    });\n  }, [queryResult.loading, queryResult.networkStatus, queryResult.error, queryResult.data]);\n  return result;\n}","map":{"version":3,"sources":["../../../../src/react/hooks/utils/useBaseQuery.ts"],"names":[],"mappings":";AAAA,SAAS,UAAU,EAAE,SAAS,EAAE,UAAU,EAAE,MAAM,QAAQ,OAAO;AAUjE,SAAS,SAAS,QAAQ,qBAAa;AACvC,SAAS,WAAW,QAAQ,kBAAgB;AAE5C,SAAS,gBAAgB,QAAQ,wBAAgB;AAEjD,OAAM,SAAU,YAAY,CAC1B,KAA0D,EAC1D,OAA6C,EAC7C,IAAY,EAAA;EAAZ,IAAA,IAAA,KAAA,KAAA,CAAA,EAAA;IAAA,IAAA,GAAA,KAAY;EAAA;EAEZ,IAAM,OAAO,GAAG,UAAU,CAAC,gBAAgB,EAAE,CAAC;EACxC,IAAA,EAAA,GAAsB,UAAU,CAAC,UAAA,CAAC,EAAA;MAAI,OAAA,CAAC,GAAG,CAAC;IAAL,CAAK,EAAE,CAAC,CAAC;IAA9C,IAAI,GAAA,EAAA,CAAA,CAAA,CAAA;IAAE,WAAW,GAAA,EAAA,CAAA,CAAA,CAA6B;EACrD,IAAM,cAAc,GAAG,OAAO,GAAE,QAAA,CAAA,QAAA,CAAA,CAAA,CAAA,EAAM,OAAO,CAAA,EAAA;IAAE,KAAK,EAAA;EAAA,CAAA,CAAA,GAAK;IAAE,KAAK,EAAA;EAAA,CAAE;EAElE,IAAM,YAAY,GAAG,MAAM,EAAgC;EAC3D,IAAM,SAAS,GAAG,YAAY,CAAC,OAAO,KACpC,YAAY,CAAC,OAAO,GAAG,IAAI,SAAS,CAAoB;IACtD,OAAO,EAAE,cAAqD;IAC9D,OAAO,EAAA,OAAA;IACP,SAAS,EAAA,qBAAA;MACP,IAAI,CAAC,SAAS,CAAC,YAAY,EAAE,EAAE;QAO7B,OAAO,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,YAAA;UAAM,OAAA,YAAY,CAAC,OAAO,IAAI,WAAW,EAAE;QAArC,CAAqC,CAAC;OACpE,MAAM;QAGL,WAAW,EAAE;MACd;IACH;GACD,CAAC,CACH;EAED,SAAS,CAAC,UAAU,CAAC,cAAc,CAAC;EACpC,SAAS,CAAC,OAAO,GAAG,OAAO;EAK3B,IAAM,IAAI,GAAG;IACX,OAAO,EAAE,QAAA,CAAA,QAAA,CAAA,CAAA,CAAA,EACJ,cAAc,CAAA,EAAA;MACjB,OAAO,EAAE,SAAS;MAClB,WAAW,EAAE;IAAS,CAAA,CACgB;IACxC,OAAO,EAAA,OAAA;IACP,IAAI,EAAA;GACL;EAED,IAAM,MAAM,GAAG,WAAW,CACxB,YAAA;IAAM,OAAC,IAAI,GAAG,SAAS,CAAC,WAAW,EAAE,GAAG,SAAS,CAAC,OAAO,EAAE;EAArD,CAAsD,EAC5D,IAAI,CACL;EAED,IAAM,WAAW,GAAG,IAAI,GACnB,MAAwC,CAAC,CAAC,CAAC,GAC3C,MAAyC;EAE9C,SAAS,CAAC,YAAA;IACR,OAAO,YAAA;MAAM,OAAA,SAAS,CAAC,OAAO,EAAE;IAAnB,CAAmB;EAClC,CAAC,EAAE,EAAE,CAAC;EAEN,SAAS,CAAC,YAAA;IAAM,OAAA,SAAS,CAAC,YAAY,CAAC;MAAE,IAAI,EAAA;IAAA,CAAE,CAAC;EAAhC,CAAgC,EAAE,CAChD,WAAW,CAAC,OAAO,EACnB,WAAW,CAAC,aAAa,EACzB,WAAW,CAAC,KAAK,EACjB,WAAW,CAAC,IAAI,CACjB,CAAC;EAEF,OAAO,MAAM;AACf","sourcesContent":["import { useContext, useEffect, useReducer, useRef } from 'react';\nimport { DocumentNode } from 'graphql';\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\n\nimport {\n  QueryHookOptions,\n  QueryDataOptions,\n  QueryTuple,\n  QueryResult,\n} from '../../types/types';\nimport { QueryData } from '../../data';\nimport { useDeepMemo } from './useDeepMemo';\nimport { OperationVariables } from '../../../core';\nimport { getApolloContext } from '../../context';\n\nexport function useBaseQuery<TData = any, TVariables = OperationVariables>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: QueryHookOptions<TData, TVariables>,\n  lazy = false\n) {\n  const context = useContext(getApolloContext());\n  const [tick, forceUpdate] = useReducer(x => x + 1, 0);\n  const updatedOptions = options ? { ...options, query } : { query };\n\n  const queryDataRef = useRef<QueryData<TData, TVariables>>();\n  const queryData = queryDataRef.current || (\n    queryDataRef.current = new QueryData<TData, TVariables>({\n      options: updatedOptions as QueryDataOptions<TData, TVariables>,\n      context,\n      onNewData() {\n        if (!queryData.ssrInitiated()) {\n          // When new data is received from the `QueryData` object, we want to\n          // force a re-render to make sure the new data is displayed. We can't\n          // force that re-render if we're already rendering however so to be\n          // safe we'll trigger the re-render in a microtask. In case the\n          // component gets unmounted before this callback fires, we re-check\n          // queryDataRef.current before calling forceUpdate().\n          Promise.resolve().then(() => queryDataRef.current && forceUpdate());\n        } else {\n          // If we're rendering on the server side we can force an update at\n          // any point.\n          forceUpdate();\n        }\n      }\n    })\n  );\n\n  queryData.setOptions(updatedOptions);\n  queryData.context = context;\n\n  // `onError` and `onCompleted` callback functions will not always have a\n  // stable identity, so we'll exclude them from the memoization key to\n  // prevent `afterExecute` from being triggered un-necessarily.\n  const memo = {\n    options: {\n      ...updatedOptions,\n      onError: undefined,\n      onCompleted: undefined\n    } as QueryHookOptions<TData, TVariables>,\n    context,\n    tick\n  };\n\n  const result = useDeepMemo(\n    () => (lazy ? queryData.executeLazy() : queryData.execute()),\n    memo\n  );\n\n  const queryResult = lazy\n    ? (result as QueryTuple<TData, TVariables>)[1]\n    : (result as QueryResult<TData, TVariables>);\n\n  useEffect(() => {\n    return () => queryData.cleanup();\n  }, []);\n\n  useEffect(() => queryData.afterExecute({ lazy }), [\n    queryResult.loading,\n    queryResult.networkStatus,\n    queryResult.error,\n    queryResult.data,\n  ]);\n\n  return result;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}