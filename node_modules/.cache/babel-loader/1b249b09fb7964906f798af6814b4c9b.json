{"ast":null,"code":"import { NetworkStatus } from \"./networkStatus.js\";\nimport { compact } from \"../utilities/index.js\";\nimport { invariant } from 'ts-invariant';\nvar Reobserver = function () {\n  function Reobserver(observer, options, fetch, shouldFetch) {\n    this.observer = observer;\n    this.options = options;\n    this.fetch = fetch;\n    this.shouldFetch = shouldFetch;\n  }\n  Reobserver.prototype.reobserve = function (newOptions, newNetworkStatus) {\n    if (newOptions) {\n      this.updateOptions(newOptions);\n    } else {\n      this.updatePolling();\n    }\n    var concast = this.fetch(this.options, newNetworkStatus);\n    if (this.concast) {\n      this.concast.removeObserver(this.observer, true);\n    }\n    concast.addObserver(this.observer);\n    return (this.concast = concast).promise;\n  };\n  Reobserver.prototype.updateOptions = function (newOptions) {\n    Object.assign(this.options, compact(newOptions));\n    this.updatePolling();\n    return this;\n  };\n  Reobserver.prototype.stop = function () {\n    if (this.concast) {\n      this.concast.removeObserver(this.observer);\n      delete this.concast;\n    }\n    if (this.pollingInfo) {\n      clearTimeout(this.pollingInfo.timeout);\n      this.options.pollInterval = 0;\n      this.updatePolling();\n    }\n  };\n  Reobserver.prototype.updatePolling = function () {\n    var _this = this;\n    var _a = this,\n      pollingInfo = _a.pollingInfo,\n      pollInterval = _a.options.pollInterval;\n    if (!pollInterval) {\n      if (pollingInfo) {\n        clearTimeout(pollingInfo.timeout);\n        delete this.pollingInfo;\n      }\n      return;\n    }\n    if (pollingInfo && pollingInfo.interval === pollInterval) {\n      return;\n    }\n    process.env.NODE_ENV === \"production\" ? invariant(pollInterval, 20) : invariant(pollInterval, 'Attempted to start a polling query without a polling interval.');\n    if (this.shouldFetch === false) {\n      return;\n    }\n    var info = pollingInfo || (this.pollingInfo = {});\n    info.interval = pollInterval;\n    var maybeFetch = function maybeFetch() {\n      if (_this.pollingInfo) {\n        if (_this.shouldFetch && _this.shouldFetch()) {\n          _this.reobserve({\n            fetchPolicy: \"network-only\",\n            nextFetchPolicy: _this.options.fetchPolicy || \"cache-first\"\n          }, NetworkStatus.poll).then(poll, poll);\n        } else {\n          poll();\n        }\n      }\n      ;\n    };\n    var poll = function poll() {\n      var info = _this.pollingInfo;\n      if (info) {\n        clearTimeout(info.timeout);\n        info.timeout = setTimeout(maybeFetch, info.interval);\n      }\n    };\n    poll();\n  };\n  return Reobserver;\n}();\nexport { Reobserver };","map":{"version":3,"sources":["../../src/core/Reobserver.ts"],"names":[],"mappings":"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","sourcesContent":["import { WatchQueryOptions } from './watchQueryOptions';\nimport { NetworkStatus } from './networkStatus';\nimport { ApolloQueryResult } from './types';\nimport { Observer, Concast, compact } from '../utilities';\nimport { invariant } from 'ts-invariant';\n\n// Given that QueryManager#fetchQueryObservable returns only a single\n// query's worth of results, other code must be responsible for repeatedly\n// calling fetchQueryObservable, while ensuring that the ObservableQuery\n// consuming those results remains subscribed to the concatenation of all\n// the observables returned by fetchQueryObservable. That responsibility\n// falls to this Reobserver class. As a bonus, the Reobserver class is\n// perfectly poised to handle polling logic, since polling is essentially\n// repeated reobservation. In principle, this code could have remained in\n// the ObservableQuery class, but I felt it would be easier to explain and\n// understand reobservation if it was confined to a separate class.\nexport class Reobserver<TData, TVars> {\n  constructor(\n    private observer: Observer<ApolloQueryResult<TData>>,\n    private options: WatchQueryOptions<TVars, TData>,\n    // Almost certainly just a wrapper function around\n    // QueryManager#fetchQueryObservable, but this small dose of\n    // indirection means the Reobserver doesn't have to know/assume\n    // anything about the QueryManager class.\n    private fetch: (\n      options: WatchQueryOptions<TVars, TData>,\n      newNetworkStatus?: NetworkStatus,\n    ) => Concast<ApolloQueryResult<TData>>,\n    // If we're polling, there may be times when we should avoid fetching,\n    // such as when the query is already in flight, or polling has been\n    // completely disabled for server-side rendering. Passing false for\n    // this parameter disables polling completely, and passing a boolean\n    // function allows determining fetch safety dynamically.\n    private shouldFetch: false | (() => boolean),\n  ) {}\n\n  private concast?: Concast<ApolloQueryResult<TData>>;\n\n  public reobserve(\n    newOptions?: Partial<WatchQueryOptions<TVars, TData>>,\n    newNetworkStatus?: NetworkStatus,\n  ): Promise<ApolloQueryResult<TData>> {\n    if (newOptions) {\n      this.updateOptions(newOptions);\n    } else {\n      // When we call this.updateOptions(newOptions) in the branch above,\n      // it takes care of calling this.updatePolling(). In this branch, we\n      // still need to update polling, even if there were no newOptions.\n      this.updatePolling();\n    }\n\n    const concast = this.fetch(this.options, newNetworkStatus);\n\n    if (this.concast) {\n      // We use the {add,remove}Observer methods directly to avoid\n      // wrapping observer with an unnecessary SubscriptionObserver\n      // object, in part so that we can remove it here without triggering\n      // any unsubscriptions, because we just want to ignore the old\n      // observable, not prematurely shut it down, since other consumers\n      // may be awaiting this.concast.promise.\n      this.concast.removeObserver(this.observer, true);\n    }\n\n    concast.addObserver(this.observer);\n\n    return (this.concast = concast).promise;\n  }\n\n  public updateOptions(newOptions: Partial<WatchQueryOptions<TVars, TData>>) {\n    Object.assign(this.options, compact(newOptions));\n    this.updatePolling();\n    return this;\n  }\n\n  public stop() {\n    if (this.concast) {\n      this.concast.removeObserver(this.observer);\n      delete this.concast;\n    }\n\n    if (this.pollingInfo) {\n      clearTimeout(this.pollingInfo.timeout);\n      this.options.pollInterval = 0;\n      this.updatePolling();\n    }\n  }\n\n  private pollingInfo?: {\n    interval: number;\n    timeout: ReturnType<typeof setTimeout>;\n  };\n\n  // Turns polling on or off based on this.options.pollInterval.\n  private updatePolling() {\n    const {\n      pollingInfo,\n      options: {\n        pollInterval,\n      },\n    } = this;\n\n    if (!pollInterval) {\n      if (pollingInfo) {\n        clearTimeout(pollingInfo.timeout);\n        delete this.pollingInfo;\n      }\n      return;\n    }\n\n    if (pollingInfo &&\n        pollingInfo.interval === pollInterval) {\n      return;\n    }\n\n    invariant(\n      pollInterval,\n      'Attempted to start a polling query without a polling interval.',\n    );\n\n    // Go no further if polling is disabled.\n    if (this.shouldFetch === false) {\n      return;\n    }\n\n    const info = pollingInfo || (\n      this.pollingInfo = {} as Reobserver<TData, TVars>[\"pollingInfo\"]\n    )!;\n\n    info.interval = pollInterval;\n\n    const maybeFetch = () => {\n      if (this.pollingInfo) {\n        if (this.shouldFetch && this.shouldFetch()) {\n          this.reobserve({\n            fetchPolicy: \"network-only\",\n            nextFetchPolicy: this.options.fetchPolicy || \"cache-first\",\n          }, NetworkStatus.poll).then(poll, poll);\n        } else {\n          poll();\n        }\n      };\n    };\n\n    const poll = () => {\n      const info = this.pollingInfo;\n      if (info) {\n        clearTimeout(info.timeout);\n        info.timeout = setTimeout(maybeFetch, info.interval);\n      }\n    };\n\n    poll();\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}